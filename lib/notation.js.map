{"version":3,"sources":["webpack://notation/webpack/universalModuleDefinition","webpack://notation/webpack/bootstrap","webpack://notation/./src/core/notation.error.js","webpack://notation/./src/core/notation.glob.js","webpack://notation/./src/core/notation.js","webpack://notation/./src/index.js","webpack://notation/./src/utils.js"],"names":["setProto","Object","setPrototypeOf","NotationError","message","prototype","defineProperty","enumerable","writable","value","Error","hasOwnProperty","captureStackTrace","stack","reMATCHER","reVALIDATOR","RegExp","re","utils","ERR_INVALID","NotationGlob","glob","ins","_inspect","notes","split","absGlob","last","length","parent","slice","replace","_","regexp","toRegExp","notation","Notation","isValid","_covers","restrictive","_intersect","isNegated","test","WILDCARDS","g","indexOf","pregQuote","globA","globB","a","b","notesA","notesB","covers","i","_coversNote","bang","len","Math","max","notesI","push","WILDCARD","joinNotes","normalizeGlobStr","normalize","match","wildCountA","wildCountB","globList","sort","compare","original","ensureArray","list","concat","_negFirstSort","_negLastSort","map","negateAll","normalized","ignored","intersections","checkAddIntersection","gA","gB","inter","hasInverted","_invert","eachRight","indexA","NEGATE_ALL","duplicate","hasExactNeg","negCoversPos","negCoveredByPos","negCoveredByNeg","posCoversPos","posCoveredByNeg","posCoveredByPos","indexB","splice","_isReverseOf","coversB","coveredByB","keepNeg","keepPos","keep","keys","globsListA","globsListB","union","notCovered","hasExact","negCoversNeg","posCoversNeg","globsA","globsB","_compareUnion","listA","listB","bIsArr","ARRAY_GLOB_NOTE","_rx","ERR","SOURCE","DEST","NOTATION","NOTA_OBJ","NO_INDEX","NO_PROP","DEFAULT_OPTS","freeze","strict","preserveIndices","source","options","src","arguments","isCollection","_source","_isArray","type","callback","_each","level","eachNote","levelNotation","note","index","hasOwn","undefined","each","o","key","create","merge","expand","result","has","lastNoteNormalized","normalizeNote","lastNote","parentIsArray","parentNotation","get","inspect","defaultValue","msg","overwrite","trim","currentIsLast","nCurrentNote","nNextNote","nextIsArrayNote","notationsObject","set","notations","inspectRemove","globs","empty","copy","deepCopy","firstIsWildcard","filtered","shift","endStar","globNotation","remove","copyFrom","originalNotation","destination","newNotation","newN","getNewNotation","target","moveTo","rename","copyTo","extract","extrude","_options","countNotes","levelNotes","join","Glob","collection","topSource","byLevel","eachItem","keyOrIndex","currentNotation","objProto","symValueOf","Symbol","valueOf","VAR","ARRAY_NOTE","OBJECT_BRACKETS","NON_NEG_WILDCARD_TRAIL","_reFlags","toString","call","toLowerCase","t","isset","isArr","Date","flags","exec","constructor","lastIndex","entries","k","v","configurable","array","thisArg","apply","eachProp","object","str","String","stringOrArrayOf","hasSingleItemOf","arr","itemValue","m","parseInt","current","next","dot","errMsg"],"mappings":"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","file":"notation.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"notation\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"notation\"] = factory();\n\telse\n\t\troot[\"notation\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"lib/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","/* eslint consistent-this:0, no-prototype-builtins:0 */\n\nconst setProto = Object.setPrototypeOf;\n\n/**\n *  Error class specific to `Notation`.\n *  @name Notation.Error\n *  @memberof! Notation\n *  @class\n *\n */\nclass NotationError extends Error {\n\n    /**\n     *  Initializes a new `Notation.Error` instance.\n     *  @constructs Notation.Error\n     *  @param {String} message - The error message.\n     */\n    constructor(message = '') {\n        super(message);\n        setProto(this, NotationError.prototype);\n\n        Object.defineProperty(this, 'name', {\n            enumerable: false,\n            writable: false,\n            value: 'NotationError'\n        });\n\n        Object.defineProperty(this, 'message', {\n            enumerable: false,\n            writable: true,\n            value: message\n        });\n\n        /* istanbul ignore else */\n        if (Error.hasOwnProperty('captureStackTrace')) { // V8\n            Error.captureStackTrace(this, NotationError);\n        } else {\n            Object.defineProperty(this, 'stack', {\n                enumerable: false,\n                writable: false,\n                value: (new Error(message)).stack\n            });\n        }\n    }\n\n}\n\nexport { NotationError };\n","/* eslint no-use-before-define:0, consistent-return:0, max-statements:0 */\n\nimport { Notation } from './notation';\nimport { NotationError } from './notation.error';\nimport { utils } from '../utils';\n\n// http://www.linfo.org/wildcard.html\n// http://en.wikipedia.org/wiki/Glob_%28programming%29\n// http://en.wikipedia.org/wiki/Wildcard_character#Computing\n\n// created test @ https://regex101.com/r/U08luj/2\nconst reMATCHER = /(\\[(\\d+|\\*|\".*\"|'.*')\\]|[a-z$_][a-z$_\\d]*|\\*)/gi; // ! negation should be removed first\n// created test @ https://regex101.com/r/mC8unE/3\n// /^!?(\\*|[a-z$_][a-z$_\\d]*|\\[(\\d+|\".*\"|'.*'|`.*`|\\*)\\])(\\[(\\d+|\".*\"|'.*'|`.*`|\\*)\\]|\\.[a-z$_][a-z$_\\d]*|\\.\\*)*$/i\nconst reVALIDATOR = new RegExp(\n    '^'\n    + '!?('                             // optional negation, only in the front\n    + '\\\\*'                             // wildcard star\n    + '|'                               // OR\n    + '[a-z$_][a-z$_\\\\d]*'              // JS variable syntax\n    + '|'                               // OR\n    + '\\\\[(\\\\d+|\\\\*|\".*\"|\\'.*\\')\\\\]'    // array index or wildcard, or object bracket notation\n    + ')'                               // exactly once\n    + '('\n    + '\\\\[(\\\\d+|\\\\*|\".*\"|\\'.*\\')\\\\]'    // followed by same\n    + '|'                               // OR\n    + '\\\\.[a-z$_][a-z$_\\\\d]*'           // dot, then JS variable syntax\n    + '|'                               // OR\n    + '\\\\.\\\\*'                          // dot, then wildcard star\n    + ')*'                              // (both) may repeat any number of times\n    + '$'\n    , 'i'\n);\n\nconst { re } = utils;\nconst ERR_INVALID = 'Invalid glob notation: ';\n\n/**\n *  `Notation.Glob` is a utility for validating, comparing and sorting\n *  dot-notation globs.\n *\n *  You can use {@link http://www.linfo.org/wildcard.html|wildcard} stars `*`\n *  and negate the notation by prepending a bang `!`. A star will include all\n *  the properties at that level and a negated notation will be excluded.\n *  @name Notation.Glob\n *  @memberof! Notation\n *  @class\n *\n *  @example\n *  // for the following object;\n *  { name: 'John', billing: { account: { id: 1, active: true } } };\n *\n *  'billing.account.*'  // represents value `{ id: 1, active: true }`\n *  'billing.account.id' // represents value `1`\n *  '!billing.account.*' // represents value `{ name: 'John' }`\n *  'name' // represents `'John'`\n *  '*' // represents the whole object\n *\n *  @example\n *  var glob = new Notation.Glob('billing.account.*');\n *  glob.test('billing.account.id'); // true\n */\nclass NotationGlob {\n\n    /**\n     *  Constructs a `Notation.Glob` object with the given glob string.\n     *  @constructs Notation.Glob\n     *  @param {String} glob - Notation string with globs.\n     *\n     *  @throws {NotationError} - If given notation glob is invalid.\n     */\n    constructor(glob) {\n        const ins = NotationGlob._inspect(glob);\n        const notes = NotationGlob.split(ins.absGlob, true);\n        const last = notes[notes.length - 1];\n        const parent = notes.length > 1\n            ? ins.absGlob.slice(0, -last.length).replace(/\\.$/, '')\n            : null;\n        this._ = {\n            ...ins,\n            regexp: NotationGlob.toRegExp(ins.absGlob),\n            notes,\n            last,\n            parent\n        };\n    }\n\n    // --------------------------------\n    // INSTANCE PROPERTIES\n    // --------------------------------\n\n    /**\n     *  Gets the normalized glob notation string.\n     *  @name Notation.Glob#glob\n     *  @type {String}\n     */\n    get glob() {\n        return this._.glob;\n    }\n\n    /**\n     *  Gets the absolute glob notation without the negation prefix `!` and\n     *  redundant trailing wildcards.\n     *  @name Notation.Glob#absGlob\n     *  @type {String}\n     */\n    get absGlob() {\n        return this._.absGlob;\n    }\n\n    /**\n     *  Specifies whether this glob is negated with a `!` prefix.\n     *  @name Notation.Glob#isNegated\n     *  @type {Boolean}\n     */\n    get isNegated() {\n        return this._.isNegated;\n    }\n\n    /**\n     *  Represents this glob in regular expressions.\n     *  Note that the negation prefix (`!`) is ignored, if any.\n     *  @name Notation.Glob#regexp\n     *  @type {RegExp}\n     */\n    get regexp() {\n        return this._.regexp;\n    }\n\n    /**\n     *  List of notes/levels of this glob notation. Note that trailing,\n     *  redundant wildcards are removed from the original glob notation.\n     *  @name Notation.Glob#notes\n     *  @alias Notation.Glob#levels\n     *  @type {Array}\n     */\n    get notes() {\n        return this._.notes;\n    }\n\n    /**\n     *  Alias of `Notation.Glob#notes`.\n     *  @private\n     *  @name Notation.Glob#notes\n     *  @alias Notation.Glob#levels\n     *  @type {Array}\n     */\n    get levels() {\n        return this._.notes;\n    }\n\n    /**\n     *  Gets the first note of this glob notation.\n     *  @name Notation.Glob#first\n     *  @type {String}\n     */\n    get first() {\n        return this.notes[0];\n    }\n\n    /**\n     *  Gets the last note of this glob notation.\n     *  @name Notation.Glob#last\n     *  @type {String}\n     */\n    get last() {\n        return this._.last;\n    }\n\n    /**\n     *  Gets the parent notation (up to but excluding the last note) from the\n     *  glob notation string. Note that initially, trailing/redundant wildcards\n     *  are removed.\n     *  @name Notation.Glob#parent\n     *  @type {String}\n     *\n     *  @example\n     *  NotationGlob.create('first.second.*').parent; // \"first.second\"\n     *  NotationGlob.create('*.x.*').parent; // \"*\"\n     *  NotationGlob.create('*').parent; // null (no parent)\n     */\n    get parent() {\n        return this._.parent;\n    }\n\n    // --------------------------------\n    // INSTANCE METHODS\n    // --------------------------------\n\n    /**\n     *  Checks whether the given notation value matches the source notation\n     *  glob.\n     *  @name Notation.Glob#test\n     *  @function\n     *  @param {String} notation - The notation string to be tested. Cannot have\n     *  any globs.\n     *  @returns {Boolean} -\n     *  @throws {NotationError} - If given `notation` is not valid or contains\n     *  any globs.\n     *\n     *  @example\n     *  const glob = new Notation.Glob('!prop.*.name');\n     *  glob.test(\"prop.account.name\"); // true\n     */\n    test(notation) {\n        if (!Notation.isValid(notation)) {\n            throw new NotationError(`Invalid notation: '${notation}'`);\n        }\n        // return this.regexp.test(notation);\n        return NotationGlob._covers(this, notation);\n    }\n\n    /**\n     *  Specifies whether this glob notation can represent (or cover) the given\n     *  glob notation. Note that negation prefix is ignored, if any.\n     *  @param {String|Array|NotationGlob} glob  Glob notation string, glob\n     *  notes array or a `NotationGlob` instance.\n     *  @returns {Boolean} -\n     *\n     *  @example\n     *  const glob = Notation.Glob.create;\n     *  glob('*.y').covers('x.y')      // true\n     *  glob('x[*].y').covers('x[*]')  // false\n     */\n    covers(glob) {\n        return NotationGlob._covers(this, glob);\n    }\n\n    /**\n     *  Gets the intersection of this and the given glob notations. When\n     *  restrictive, if any one of them is negated, the outcome is negated.\n     *  Otherwise, only if both of them are negated, the outcome is negated.\n     *  @param {String} glob - Second glob to be used.\n     *  @param {Boolean} [restrictive=false] - Whether the intersection should\n     *  be negated when one of the globs is negated.\n     *  @returns {String} - Intersection notation if any; otherwise `null`.\n     *  @example\n     *  const glob = Notation.Glob.create;\n     *  glob('x.*').intersect('!*.y')         // 'x.y'\n     *  glob('x.*').intersect('!*.y', true)   // '!x.y'\n     */\n    intersect(glob, restrictive = false) {\n        return NotationGlob._intersect(this.glob, glob, restrictive);\n    }\n\n    // --------------------------------\n    // STATIC MEMBERS\n    // --------------------------------\n\n    /**\n     *  Basically constructs a new `NotationGlob` instance\n     *  with the given glob string.\n     *  @name Notation.Glob.create\n     *  @function\n     *  @param {String} glob - The source notation glob.\n     *  @returns {NotationGlob} -\n     *\n     *  @example\n     *  const glob = Notation.Glob.create(strGlob);\n     *  // equivalent to:\n     *  const glob = new Notation.Glob(strGlob);\n     */\n    static create(glob) {\n        return new NotationGlob(glob);\n    }\n\n    // Created test at: https://regex101.com/r/tJ7yI9/4\n    /**\n     *  Validates the given notation glob.\n     *  @name Notation.Glob.isValid\n     *  @function\n     *\n     *  @param {String} glob - Notation glob to be validated.\n     *  @returns {Boolean} -\n     */\n    static isValid(glob) {\n        return typeof glob === 'string' && reVALIDATOR.test(glob);\n    }\n\n    /**\n     *  Specifies whether the given glob notation includes any valid wildcards\n     *  or negation bang prefix.\n     *  @param {String} glob - Glob notation to be checked.\n     *  @returns {Boolean} -\n     */\n    static hasMagic(glob) {\n        return NotationGlob.isValid(glob) && (re.WILDCARDS.test(glob) || glob[0] === '!');\n    }\n\n    /**\n     *  Gets a regular expressions instance from the given glob notation.\n     *  Note that the bang `!` prefix will be ignored if the given glob is negated.\n     *  @name Notation.Glob.toRegExp\n     *  @function\n     *  @param {String} glob - Glob notation to be converted.\n     *\n     *  @returns {RegExp} - A `RegExp` instance from the glob.\n     *\n     *  @throws {NotationError} - If given notation glob is invalid.\n     */\n    static toRegExp(glob) {\n        if (!NotationGlob.isValid(glob)) {\n            throw new NotationError(`${ERR_INVALID} '${glob}'`);\n        }\n\n        let g = glob.indexOf('!') === 0 ? glob.slice(1) : glob;\n        g = utils.pregQuote(g)\n            // `[*]` always represents array index e.g. `[1]`. so we'd replace\n            // `\\[\\*\\]` with `\\[\\d+\\]` but we should also watch for quotes: e.g.\n            // `[\"x[*]y\"]`\n            .replace(/\\\\\\[\\\\\\*\\\\\\](?=(?:[^\"]|\"[^\"]*\")*$)(?=(?:[^']|'[^']*')*$)/g, '\\\\[\\\\d+\\\\]')\n            // `*` within quotes (e.g. ['*']) is non-wildcard, just a regular star char.\n            // `*` outside of quotes is always JS variable syntax e.g. `prop.*`\n            .replace(/\\\\\\*(?=(?:[^\"]|\"[^\"]*\")*$)(?=(?:[^']|'[^']*')*$)/g, '[a-z$_][a-z$_\\\\d]*')\n            .replace(/\\\\\\?/g, '.');\n        return new RegExp('^' + g + '(?:[\\\\[\\\\.].+|$)', 'i');\n        // it should either end ($) or continue with a dot or bracket. So for\n        // example, `company.*` will produce `/^company\\.[a-z$_][a-z$_\\\\d]*(?:[\\\\[|\\\\.].+|$)/`\n        // which will match both `company.name` and `company.address.street` but\n        // will not match `some.company.name`. Also `!password` will not match\n        // `!password_reset`.\n    }\n\n    /**\n     *  Specifies whether first glob notation can represent (or cover) the\n     *  second.\n     *  @private\n     *  @param {String|Object|NotationGlob} globA  Source glob notation string or inspection\n     *  result object or `NotationGlob` instance.\n     *  @param {String|Object|NotationGlob} globB  Glob notation string or inspection result\n     *  object or `NotationGlob` instance.\n     *  @returns {Boolean} -\n     *\n     *  @example\n     *  const { covers } = NotationGlob;\n     *  covers('*.y', 'x.y')      // true\n     *  covers('x[*].y', 'x[*]')  // false\n     */\n    static _covers(globA, globB) {\n        const a = typeof globA === 'string'\n            ? new NotationGlob(globA)\n            : globA; // assume (globA instanceof NotationGlob || utils.type(globA) === 'object')\n\n        const b = typeof globB === 'string'\n            ? new NotationGlob(globB)\n            : globB;\n\n        const notesA = a.notes || NotationGlob.split(a.absGlob);\n        const notesB = b.notes || NotationGlob.split(b.absGlob);\n\n        // !x.*.* does not cover !x.* or x.* bec. !x.*.* !== x.* !== x\n        // x.*.* covers x.* bec. x.*.* === x.* === x\n        if (a.isNegated && notesA.length > notesB.length) return false;\n\n        let covers = true;\n        for (let i = 0; i < notesA.length; i++) {\n            if (!_coversNote(notesA[i], notesB[i])) {\n                covers = false;\n                break;\n            }\n        }\n        return covers;\n    }\n\n    /**\n     *  Gets the intersection notation of two glob notations. When restrictive,\n     *  if any one of them is negated, the outcome is negated. Otherwise, only\n     *  if both of them are negated, the outcome is negated.\n     *  @private\n     *  @param {String} globA - First glob to be used.\n     *  @param {String} globB - Second glob to be used.\n     *  @param {Boolean} [restrictive=false] - Whether the intersection should\n     *  be negated when one of the globs is negated.\n     *  @returns {String} - Intersection notation if any; otherwise `null`.\n     *  @example\n     *  _intersect('!*.y', 'x.*', false)     // 'x.y'\n     *  _intersect('!*.y', 'x.*', true)      // '!x.y'\n     */\n    static _intersect(globA, globB, restrictive = false) {\n        // const bang = restrictive\n        //     ? (globA[0] === '!' || globB[0] === '!' ? '!' : '')\n        //     : (globA[0] === '!' && globB[0] === '!' ? '!' : '');\n\n        const notesA = NotationGlob.split(globA, true);\n        const notesB = NotationGlob.split(globB, true);\n\n        let bang;\n        if (restrictive) {\n            bang = globA[0] === '!' || globB[0] === '!' ? '!' : '';\n        } else {\n            if (globA[0] === '!' && globB[0] === '!') {\n                bang = '!';\n            } else {\n                bang = ((notesA.length > notesB.length && globA[0] === '!')\n                        || (notesB.length > notesA.length && globB[0] === '!'))\n                    ? '!'\n                    : '';\n            }\n        }\n\n        const len = Math.max(notesA.length, notesB.length);\n        let notesI = [];\n        let a, b;\n        //   x.*    *.y     x.y\n        // x.*.*    *.y     x.y.*\n        // x.*.z    *.y     x.y.z\n        //   x.y    *.b     (n/a)\n        //   x.y    a.*     (n/a)\n        for (let i = 0; i < len; i++) {\n            a = notesA[i];\n            b = notesB[i];\n            if (a === b) {\n                notesI.push(a);\n            } else if (a && re.WILDCARD.test(a)) {\n                if (!b) {\n                    notesI.push(a);\n                } else {\n                    notesI.push(b);\n                }\n            } else if (b && re.WILDCARD.test(b)) {\n                if (!a) {\n                    notesI.push(b);\n                } else {\n                    notesI.push(a);\n                }\n            } else if (a && !b) {\n                notesI.push(a);\n            } else if (!a && b) {\n                notesI.push(b);\n            } else { // if (a !== b) {\n                notesI = [];\n                break;\n            }\n        }\n\n        if (notesI.length > 0) return bang + utils.joinNotes(notesI);\n        return null;\n    }\n\n    /**\n     *  Undocumented.\n     *  @private\n     *  @param {String} glob -\n     *  @returns {Object} -\n     */\n    static _inspect(glob) {\n        const g = utils.normalizeGlobStr(glob);\n        if (!NotationGlob.isValid(g)) {\n            throw new NotationError(`${ERR_INVALID} '${glob}'`);\n        }\n        const isNegated = g[0] === '!';\n        return {\n            glob: g,\n            isNegated,\n            absGlob: isNegated ? g.slice(1) : g\n        };\n    }\n\n    /**\n     *  Splits the given glob notation string into its notes (levels). Note that\n     *  this will exclude the `!` negation prefix, if it exists.\n     *  @param {String} glob  Glob notation string to be splitted.\n     *  @param {String} [normalize=false]  Whether to remove trailing, redundant\n     *  wildcards.\n     *  @returns {Array} - A string array of glob notes (levels).\n     *  @throws {NotationError} - If given glob notation is invalid.\n     *  @example\n     *  Notation.Glob.split('*.list[2].value')  // ['*', 'list', '[2]', 'value']\n     *  // you can get the same result from the .notes property of a Notation.Glob instance.\n     */\n    static split(glob, normalize = false) {\n        if (!NotationGlob.isValid(glob)) {\n            throw new NotationError(`${ERR_INVALID} '${glob}'`);\n        }\n        const g = normalize ? utils.normalizeGlobStr(glob) : glob;\n        return g.replace(/^!/, '').match(reMATCHER);\n    }\n\n    /**\n     *  Compares two given notation globs and returns an integer value as a\n     *  result. This is generally used to sort glob arrays. Loose globs (with\n     *  stars especially closer to beginning of the glob string) and globs\n     *  representing the parent/root of the compared property glob come first.\n     *  Verbose/detailed/exact globs come last. (`* < *.abc < abc`).\n     *\n     *  For instance; `store.address` comes before `store.address.street`. So\n     *  this works both for `*, store.address.street, !store.address` and `*,\n     *  store.address, !store.address.street`. For cases such as `prop.id` vs\n     *  `!prop.id` which represent the same property; the negated glob comes\n     *  last.\n     *  @name Notation.Glob.compare\n     *  @function\n     *\n     *  @param {String} globA - First notation glob to be compared.\n     *  @param {String} globB - Second notation glob to be compared.\n     *\n     *  @returns {Number} - Returns `-1` if `globA` comes first, `1` if `globB`\n     *  comes first and `0` if equivalent priority.\n     *\n     *  @throws {NotationError} - If either `globA` or `globB` is invalid glob\n     *  notation.\n     *\n     *  @example\n     *  const { compare } = Notation.Glob;\n     *  compare('*', 'info.user')               // -1\n     *  compare('*', '[*]')                     // 0\n     *  compare('info.*.name', 'info.user')     // 1\n     */\n    static compare(globA, globB) {\n        // trivial case, both are exactly the same!\n        // or both are wildcard e.g. `*` or `[*]`\n        if (globA === globB || (re.WILDCARD.test(globA) && re.WILDCARD.test(globB))) return 0;\n\n        const { split, _inspect } = NotationGlob;\n\n        const a = _inspect(globA);\n        const b = _inspect(globB);\n        const notesA = split(a.absGlob);\n        const notesB = split(b.absGlob);\n\n        // Check depth (number of levels)\n        if (notesA.length === notesB.length) {\n            // count wildcards\n            const wildCountA = (a.absGlob.match(re.WILDCARDS) || []).length;\n            const wildCountB = (b.absGlob.match(re.WILDCARDS) || []).length;\n            if (wildCountA === wildCountB) {\n                // check for negation\n                if (!a.isNegated && b.isNegated) return -1;\n                if (a.isNegated && !b.isNegated) return 1;\n                // both are negated or neither are, return alphabetical\n                return a.absGlob < b.absGlob ? -1 : (a.absGlob > b.absGlob ? 1 : 0);\n            }\n            return wildCountA > wildCountB ? -1 : 1;\n        }\n\n        return notesA.length < notesB.length ? -1 : 1;\n    }\n\n    /**\n     *  Sorts the notation globs in the given array by their priorities. Loose\n     *  globs (with stars especially closer to beginning of the glob string);\n     *  globs representing the parent/root of the compared property glob come\n     *  first. Verbose/detailed/exact globs come last. (`* < *abc < abc`).\n     *\n     *  For instance; `store.address` comes before `store.address.street`. For\n     *  cases such as `prop.id` vs `!prop.id` which represent the same property;\n     *  the negated glob wins (comes last).\n     *  @name Notation.Glob.sort\n     *  @function\n     *  @param {Array} globList - The notation globs array to be sorted. The\n     *  passed array reference is modified.\n     *  @returns {Array} -\n     *\n     *  @example\n     *  const { sort } = Notation.Glob;\n     *  sort(['!prop.*.name', 'prop.*', 'prop.id'])\n     *  // ['prop.*', 'prop.id', '!prop.*.name'];\n     */\n    static sort(globList) {\n        return globList.sort(NotationGlob.compare);\n    }\n\n    /**\n     *  Normalizes the given notation globs array by removing duplicate or\n     *  redundant items, eliminating extra verbosity (also with intersection\n     *  globs) and returns a priority-sorted globs array.\n     *\n     *  <ul>\n     *  <li>If any exact duplicates found, all except first is removed.\n     *  <br />example: `['car', 'dog', 'car']` normalizes to `['car', 'dog']`.</li>\n     *  <li>If both normal and negated versions of a glob are found, negated wins.\n     *  <br />example: `['*', 'id', '!id']` normalizes to `['*', '!id']`.</li>\n     *  <li>If a glob is covered by another, it's removed.\n     *  <br />example: `['car.*', 'car.model']` normalizes to `['car']`.</li>\n     *  <li>If a negated glob is covered by another glob, it's kept.\n     *  <br />example: `['*', 'car', '!car.model']` normalizes as is.</li>\n     *  <li>If a negated glob is not covered by another or it does not cover any other;\n     *  then we check for for intersection glob. If found, adds them to list;\n     *  removes the original negated.\n     *  <br />example: `['car.*', '!*.model']` normalizes as to `['car', '!car.model']`.</li>\n     *  <li>In restrictive mode; if a glob is covered by another negated glob, it's removed.\n     *  Otherwise, it's kept.\n     *  <br />example: `['*', '!car.*', 'car.model']` normalizes to `['*', '!car']` if restrictive.</li>\n     *  </ul>\n     *  @name Notation.Glob.normalize\n     *  @function\n     *  @param {Array} globList - Notation globs array to be normalized.\n     *  @param {Boolean} [restrictive=false] - Whether negated items strictly\n     *  remove every match. Note that, regardless of this option, if any item has an\n     *  exact negated version; non-negated is always removed.\n     *  @returns {Array} -\n     *\n     *  @throws {NotationError} - If any item in globs list is invalid.\n     *\n     *  @example\n     *  const { normalize } = Notation.Glob;\n     *  normalize(['*', '!id', 'name', '!car.model', 'car.*', 'id', 'name']);\n     *  //  ['*', '!id', '!car.model']\n     *  normalize(['!*.id', 'user.*', 'company']);\n     *  //  ['company', 'user', '!company.id', '!user.id']\n     *  normalize(['*', 'car.model', '!car.*']);\n     *  //  [\"*\", \"!car.*\", \"car.model\"]\n     *  normalize(['*', 'car.model', '!car.*'], true); // restrictive\n     *  //  [\"*\", \"!car.*\"]\n     */\n    static normalize(globList, restrictive = false) {\n        const { _inspect, _covers, _intersect } = NotationGlob;\n\n        const original = utils.ensureArray(globList);\n\n        const list = original\n            // prevent mutation\n            .concat()\n            // move negated globs to top so that we inspect non-negated globs\n            // against others first. when complete, we'll sort with our\n            // .compare() function.\n            .sort(restrictive ? _negFirstSort : _negLastSort)\n            // turning string array into inspect-obj array, so that we'll not\n            // run _inspect multiple times in the inner loop. this also\n            // pre-validates each glob.\n            .map(_inspect);\n\n        // early return if we have a single item\n        if (list.length === 1) {\n            const g = list[0];\n            // single negated item is redundant\n            if (g.isNegated) return [];\n            // return normalized\n            return [g.glob];\n        }\n\n        // flag to return an empty array (in restrictive mode), if true.\n        let negateAll = false;\n\n        // we'll push keepers in this array\n        let normalized = [];\n        // we'll need to remember excluded globs, so that we can move to next\n        // item early.\n        const ignored = {};\n\n        // storage to keep intersections.\n        // using an object to prevent duplicates.\n        let intersections = {};\n\n        const checkAddIntersection = (gA, gB) => {\n            const inter = _intersect(gA, gB, restrictive);\n            if (!inter) return;\n            // if the intersection result has an inverted version in the\n            // original list, don't add this.\n            const hasInverted = restrictive ? false : original.indexOf(_invert(inter)) >= 0;\n            // also if intersection result is in the current list, don't add it.\n            if (list.indexOf(inter) >= 0 || hasInverted) return;\n            intersections[inter] = inter;\n        };\n\n        // iterate each glob by comparing it to remaining globs.\n        utils.eachRight(list, (a, indexA) => {\n\n            // if `strict` is enabled, return empty if a negate-all is found\n            // (which itself is also redundant if single): '!*' or '![*]'\n            if (re.NEGATE_ALL.test(a.glob)) {\n                negateAll = true;\n                if (restrictive) return false;\n            }\n\n            // flags\n            let duplicate = false;\n            let hasExactNeg = false;\n            // flags for negated\n            let negCoversPos = false;\n            let negCoveredByPos = false;\n            let negCoveredByNeg = false;\n            // flags for non-negated (positive)\n            let posCoversPos = false;\n            let posCoveredByNeg = false;\n            let posCoveredByPos = false;\n\n            utils.eachRight(list, (b, indexB) => {\n                // don't inspect glob with itself\n                if (indexA === indexB) return; // move to next\n                // console.log(indexA, a.glob, 'vs', b.glob);\n\n                // remove if duplicate\n                if (a.glob === b.glob) {\n                    list.splice(indexA, 1);\n                    duplicate = true;\n                    return false; // break out\n                }\n\n                // remove if positive has an exact negated (negated wins when\n                // normalized) e.g. ['*', 'a', '!a'] => ['*', '!a']\n                if (!a.isNegated && _isReverseOf(a, b)) {\n                    // list.splice(indexA, 1);\n                    ignored[a.glob] = true;\n                    hasExactNeg = true;\n                    return false; // break out\n                }\n\n                // if already excluded b, go on to next\n                if (ignored[b.glob]) return; // next\n\n                const coversB = _covers(a, b);\n                const coveredByB = coversB ? false : _covers(b, a);\n                if (a.isNegated) {\n                    if (b.isNegated) {\n                        // if negated (a) covered by any other negated (b); remove (a)!\n                        if (coveredByB) {\n                            negCoveredByNeg = true;\n                            // list.splice(indexA, 1);\n                            ignored[a.glob] = true;\n                            return false; // break out\n                        }\n                    } else {\n                        /* istanbul ignore if */\n                        if (coversB) negCoversPos = true;\n                        if (coveredByB) negCoveredByPos = true;\n                        // try intersection if none covers the other and only\n                        // one of them is negated.\n                        if (!coversB && !coveredByB) {\n                            checkAddIntersection(a.glob, b.glob);\n                        }\n                    }\n                } else {\n                    if (b.isNegated) {\n                        // if positive (a) covered by any negated (b); remove (a)!\n                        if (coveredByB) {\n                            posCoveredByNeg = true;\n                            if (restrictive) {\n                                // list.splice(indexA, 1);\n                                ignored[a.glob] = true;\n                                return false; // break out\n                            }\n                            return; // next\n                        }\n                        // try intersection if none covers the other and only\n                        // one of them is negated.\n                        if (!coversB && !coveredByB) {\n                            checkAddIntersection(a.glob, b.glob);\n                        }\n                    } else {\n                        if (coversB) posCoversPos = coversB;\n                        // if positive (a) covered by any other positive (b); remove (a)!\n                        if (coveredByB) {\n                            posCoveredByPos = true;\n                            if (restrictive) {\n                                // list.splice(indexA, 1);\n                                return false; // break out\n                            }\n                        }\n                    }\n                }\n\n            });\n\n            // const keepNeg = (negCoversPos || negCoveredByPos) && !negCoveredByNeg;\n            const keepNeg = restrictive\n                ? (negCoversPos || negCoveredByPos) && negCoveredByNeg === false\n                : negCoveredByPos && negCoveredByNeg === false;\n            const keepPos = restrictive\n                ? (posCoversPos || posCoveredByPos === false) && posCoveredByNeg === false\n                : posCoveredByNeg || posCoveredByPos === false;\n            const keep = duplicate === false\n                && hasExactNeg === false\n                && (a.isNegated ? keepNeg : keepPos);\n\n            if (keep) {\n                normalized.push(a.glob);\n            } else {\n                // this is excluded from final (normalized) list, so mark as\n                // ignored (don't remove from \"list\" for now)\n                ignored[a.glob] = true;\n            }\n        });\n\n        if (restrictive && negateAll) return [];\n\n        intersections = Object.keys(intersections);\n        if (intersections.length > 0) {\n            // merge normalized list with intersections if any\n            normalized = normalized.concat(intersections);\n            // we have new (intersection) items, so re-normalize\n            return NotationGlob.normalize(normalized, restrictive);\n        }\n\n        return NotationGlob.sort(normalized);\n    }\n\n    /**\n     *  Undocumented. See `.union()`\n     *  @private\n     *  @param {Array} globsListA -\n     *  @param {Array} globsListB -\n     *  @param {Boolean} restrictive -\n     *  @param {Array} union -\n     *  @returns {Array} -\n     */\n    static _compareUnion(globsListA, globsListB, restrictive, union = []) {\n        const { _covers } = NotationGlob;\n\n        const { _inspect, _intersect } = NotationGlob;\n\n        utils.eachRight(globsListA, globA => {\n            if (union.indexOf(globA) >= 0) return; // next\n\n            const a = _inspect(globA);\n\n            // if wildcard only, add...\n            if (re.WILDCARD.test(a.absGlob)) {\n                union.push(a.glob); // push normalized glob\n                return; // next\n            }\n\n            let notCovered = false;\n            let hasExact = false;\n            let negCoversNeg = false;\n            let posCoversNeg = false;\n            let posCoversPos = false;\n            let negCoversPos = false;\n\n            const intersections = [];\n\n            utils.eachRight(globsListB, globB => {\n\n                // keep if has exact in the other\n                if (globA === globB) hasExact = true;\n\n                const b = _inspect(globB);\n\n                // keep negated if:\n                //    1) any negated covers it\n                //    2) no positive covers it\n                // keep positive if:\n                //    1) no positive covers it OR any negated covers it\n\n                notCovered = !_covers(b, a);\n                if (notCovered) {\n                    if (a.isNegated && b.isNegated) {\n                        const inter = _intersect(a.glob, b.glob, restrictive);\n                        if (inter && union.indexOf(inter) === -1) intersections.push(inter);\n                    }\n                    return; // next\n                }\n\n                if (a.isNegated) {\n                    if (b.isNegated) {\n                        negCoversNeg = !hasExact;\n                    } else {\n                        posCoversNeg = true; // set flag\n                    }\n                } else {\n                    if (!b.isNegated) {\n                        posCoversPos = !hasExact;\n                    } else {\n                        negCoversPos = true; // set flag\n                    }\n                }\n\n            });\n\n\n            const keep = a.isNegated\n                ? (!posCoversNeg || negCoversNeg)\n                : (!posCoversPos || negCoversPos);\n\n            if (hasExact || keep || (notCovered && !a.isNegated)) {\n                union.push(a.glob); // push normalized glob\n                return;\n            }\n\n            if (a.isNegated && posCoversNeg && !negCoversNeg && intersections.length > 0) {\n                union = union.concat(intersections); // eslint-disable-line no-param-reassign\n            }\n\n        });\n\n        return union;\n    }\n\n    /**\n     *  Gets the union from the given couple of glob arrays and returns a new\n     *  array of globs.\n     *  <ul>\n     *  <li>If the exact same element is found in both\n     *  arrays, one of them is removed to prevent duplicates.\n     *  <br />example: `['!id', 'name']  ['!id']` unites to `['!id', 'name']`</li>\n     *  <li>If any non-negated item is covered by a glob in the same\n     *  or other array, the redundant item is removed.\n     *  <br />example: `['*', 'name']  ['email']` unites to `['*']`</li>\n     *  <li>If one of the arrays contains a negated equivalent of an\n     *  item in the other array, the negated item is removed.\n     *  <br />example: `['!id']  ['id']` unites to `['id']`</li>\n     *  <li>If any item covers/matches a negated item in the other array,\n     *  the negated item is removed.\n     *  <br />example #1: `['!user.id']  ['user.*']` unites to `['user']`\n     *  <br />example #2: `['*']  ['!password']` unites to `['*']`\n     *  </li>\n     *  </ul>\n     *  @name Notation.Glob.union\n     *  @function\n     *\n     *  @param {Array} globsA - First array of glob strings.\n     *  @param {Array} globsB - Second array of glob strings.\n     *  @param {Boolean} [restrictive=false] - Whether negated items in each of\n     *  the lists, strictly remove every match in themselves (not the cross\n     *  list). This option is used when pre-normalizing each glob list and\n     *  normalizing the final union list.\n     *\n     *  @returns {Array} -\n     *\n     *  @example\n     *  const a = ['user.*', '!user.email', 'car.model', '!*.id'];\n     *  const b = ['!*.date', 'user.email', 'car', '*.age'];\n     *  const { union } = Notation.Glob;\n     *  union(a, b)     // ['car', 'user', '*.age', '!car.date', '!user.id']\n     */\n    static union(globsA, globsB, restrictive) {\n        const { normalize, _compareUnion } = NotationGlob;\n\n        const listA = normalize(globsA, restrictive);\n        const listB = normalize(globsB, restrictive);\n\n        if (listA.length === 0) return listB;\n        if (listB.length === 0) return listA;\n\n        // TODO: below should be optimized\n        let union = _compareUnion(listA, listB, restrictive);\n        union = _compareUnion(listB, listA, restrictive, union);\n        return normalize(union, restrictive);\n    }\n\n}\n\n// --------------------------------\n// HELPERS\n// --------------------------------\n\nfunction _coversNote(a, b) {\n    if (a === b) return true;\n    // if (!a && re.WILDCARD.test(b)) return false;\n    const bIsArr = b ? re.ARRAY_GLOB_NOTE.test(b) : null;\n    if (a === '*' && (!b || !bIsArr)) return true;\n    if (a === '[*]' && (!b || bIsArr)) return true;\n    return false;\n}\n\n// x vs !x.*.*       false\n// x vs !x[*]        true\n// x[*] vs !x        true\n// x[*] vs !x[*]     false\n// x.* vs !x.*       false\nfunction _isReverseOf(a, b) {\n    return a.isNegated !== b.isNegated\n        && a.absGlob === b.absGlob;\n}\n\nfunction _invert(glob) {\n    return glob[0] === '!' ? glob.slice(1) : '!' + glob;\n}\n\nconst _rx = /^\\s*!/;\nfunction _negFirstSort(a, b) {\n    return _rx.test(a) ? -1 : (_rx.test(b) ? 1 : 0);\n}\nfunction _negLastSort(a, b) {\n    return _rx.test(a) ? 1 : (_rx.test(b) ? -1 : 0);\n}\n\n// --------------------------------\n// EXPORT\n// --------------------------------\n\nexport { NotationGlob };\n","/* eslint no-use-before-define:0, consistent-return:0 */\n\nimport { NotationError } from './notation.error';\nimport { NotationGlob } from './notation.glob';\nimport { utils } from '../utils';\n\nconst ERR = {\n    SOURCE: 'Invalid source. Expected a data object or array.',\n    DEST: 'Invalid destination. Expected a data object or array.',\n    NOTATION: 'Invalid notation: ',\n    NOTA_OBJ: 'Invalid notations object. ',\n    NO_INDEX: 'Implied index does not exist: ',\n    NO_PROP: 'Implied property does not exist: '\n};\n\n// created test @ https://regex101.com/r/vLE16M/2\nconst reMATCHER = /(\\[(\\d+|\".*\"|'.*'|`.*`)\\]|[a-z$_][a-z$_\\d]*)/gi;\n// created test @ https://regex101.com/r/fL3PJt/1/\n// /^([a-z$_][a-z$_\\d]*|\\[(\\d+|\".*\"|'.*'|`.*`)\\])(\\[(\\d+|\".*\"|'.*'|`.*`)\\]|(\\.[a-z$_][a-z$_\\d]*))*$/i\nconst reVALIDATOR = new RegExp(\n    '^('\n    + '[a-z$_][a-z$_\\\\d]*'          // JS variable syntax\n    + '|'                           // OR\n    + '\\\\[(\\\\d+|\".*\"|\\'.*\\')\\\\]'    // array index or object bracket notation\n    + ')'                           // exactly once\n    + '('\n    + '\\\\[(\\\\d+|\".*\"|\\'.*\\')\\\\]'    // followed by same\n    + '|'                           // OR\n    + '\\\\.[a-z$_][a-z$_\\\\d]*'       // dot, then JS variable syntax\n    + ')*'                          // (both) may repeat any number of times\n    + '$'\n    , 'i'\n);\n\nconst DEFAULT_OPTS = Object.freeze({\n    strict: false,\n    preserveIndices: false\n});\n\n/**\n *  Notation.js for Node and Browser.\n *\n *  Like in most programming languages, JavaScript makes use of dot-notation to\n *  access the value of a member of an object (or class). `Notation` class\n *  provides various methods for modifying / processing the contents of the\n *  given object; by parsing object notation strings or globs.\n *\n *  Note that this class will only deal with enumerable properties of the source\n *  object; so it should be used to manipulate data objects. It will not deal\n *  with preserving the prototype-chain of the given object.\n *\n *  @author   Onur Yldrm <onur@cutepilot.com>\n *  @license  MIT\n */\nclass Notation {\n\n    /**\n     *  Initializes a new instance of `Notation`.\n     *\n     *  @param {Object|Array} [source={}] - The source object (or array) to be\n     *  notated. Can either be an array or object. If omitted, defaults to an\n     *  empty object.\n     *  @param {Object} [options] - Notation options.\n     *      @param {Boolean} [options.strict=false] - Whether to throw either when\n     *      a notation path does not exist on the source (i.e. `#get()` and `#remove()`\n     *      methods); or notation path exists but overwriting is disabled (i.e.\n     *      `#set()` method). (Note that `.inspect()` and `.inspectRemove()` methods\n     *      are exceptions). It's recommended to set this to `true` and prevent silent\n     *      failures if you're working with sensitive data. Regardless of `strict` option,\n     *      it will always throw on invalid notation syntax or other crucial failures.\n     *      @param {Boolean} [options.preserveIndices=false] - Indicates whether to\n     *      preserve the indices of the parent array when an item is to be removed.\n     *      By default, the item is removed completely at the implied index instead of\n     *      preserving indices by emptying the item (sparse array). So you should mind\n     *      the shifted indices when you remove an item via `.remove()`, `.inspectRemove()`\n     *      or `.filter()`.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  const notation = new Notation(obj);\n     *  notation.get('car.model')   //  \"Charger\"\n     *  notation.remove('car.model').set('car.color', 'red').value\n     *  //  { car: { brand: \"Dodge\", year: 1970, color: \"red\" } }\n     */\n    constructor(source, options) {\n        let src = source;\n        if (arguments.length === 0) {\n            src = {};\n        } else if (!utils.isCollection(source)) {\n            throw new NotationError(ERR.SOURCE);\n        }\n\n        this.options = options;\n        this._source = src;\n        this._isArray = utils.type(src) === 'array';\n    }\n\n    // --------------------------------\n    // INSTANCE PROPERTIES\n    // --------------------------------\n\n    /**\n     *  Gets or sets notation options.\n     *  @type {Object}\n     */\n    get options() {\n        return this._options;\n    }\n\n    set options(value) {\n        this._options = {\n            ...DEFAULT_OPTS,\n            ...(this._options || {}),\n            ...(value || {})\n        };\n    }\n\n    /**\n     *  Gets the value of the source object.\n     *  @type {Object|Array}\n     *\n     *  @example\n     *  const person = { name: \"Onur\" };\n     *  const me = Notation.create(person)\n     *      .set(\"age\", 36)\n     *      .set(\"car.brand\", \"Ford\")\n     *      .set(\"car.model\", \"Mustang\")\n     *      .value;\n     *  console.log(me); // { name: \"Onur\", age: 36, car: { brand: \"Ford\", model: \"Mustang\" } }\n     *  console.log(person === me); // true\n     */\n    get value() {\n        return this._source;\n    }\n\n    // --------------------------------\n    // INSTANCE METHODS\n    // --------------------------------\n\n    /**\n     *  Recursively iterates through each key of the source object and invokes\n     *  the given callback function with parameters, on each non-object value.\n     *\n     *  @param {Function} callback - The callback function to be invoked on\n     *  each on each non-object value. To break out of the loop, return `false`\n     *  from within the callback.\n     *  Callback signature: `callback(notation, key, value, object) { ... }`\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  Notation.create(obj).each(function (notation, key, value, object) {\n     *      console.log(notation, value);\n     *  });\n     *  // \"car.brand\"  \"Dodge\"\n     *  // \"car.model\"  \"Charger\"\n     *  // \"car.year\"  1970\n     */\n    each(callback) {\n        _each(this._source, callback);\n        return this;\n    }\n\n    /**\n     *  Iterates through each note of the given notation string by evaluating\n     *  it on the source object.\n     *\n     *  @param {String} notation - The notation string to be iterated through.\n     *  @param {Function} callback - The callback function to be invoked on\n     *  each iteration. To break out of the loop, return `false` from within\n     *  the callback. Signature: `callback(levelValue, note, index, list)`\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  Notation.create(obj)\n     *      .eachValue(\"car.brand\", function (levelValue, note, index, list) {\n     *          console.log(note, levelValue); // \"car.brand\" \"Dodge\"\n     *      });\n     */\n    eachValue(notation, callback) {\n        let level = this._source;\n        Notation.eachNote(notation, (levelNotation, note, index, list) => {\n            level = utils.hasOwn(level, note) ? level[note] : undefined;\n            if (callback(level, levelNotation, note, index, list) === false) return false;\n\n        });\n        return this;\n    }\n\n    /**\n     *  Gets the list of notations from the source object (keys).\n     *\n     *  @returns {Array} - An array of notation strings.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  const notations = Notation.create(obj).getNotations();\n     *  console.log(notations); // [ \"car.brand\", \"car.model\", \"car.year\" ]\n     */\n    getNotations() {\n        const list = [];\n        this.each(notation => {\n            list.push(notation);\n        });\n        return list;\n    }\n\n    /**\n     *  Flattens the source object to a single-level object with notated keys.\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  const flat = Notation.create(obj).flatten().value;\n     *  console.log(flat);\n     *  // { \"car.brand\": \"Dodge\", \"car.model\": \"Charger\", \"car.year\": 1970 }\n     */\n    flatten() {\n        const o = {};\n        this.each((notation, key, value) => {\n            o[notation] = value;\n        });\n        this._source = o;\n        return this;\n    }\n\n    /**\n     *  Aggregates notated keys of a (single-level) object, and nests them under\n     *  their corresponding properties. This is the opposite of `Notation#flatten`\n     *  method. This might be useful when expanding a flat object fetched from\n     *  a database.\n     *  @alias Notation#aggregate\n     *  @chainable\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  const obj = { \"car.brand\": \"Dodge\", \"car.model\": \"Charger\", \"car.year\": 1970 }\n     *  const expanded = Notation.create(obj).expand().value;\n     *  console.log(expanded); // { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     */\n    expand() {\n        this._source = Notation.create({}).merge(this._source).value;\n        return this;\n    }\n\n    /**\n     *  Alias for `#expand`\n     *  @private\n     *  @returns {Notation} -\n     */\n    aggregate() {\n        return this.expand();\n    }\n\n    /**\n     *  Inspects the given notation on the source object by checking\n     *  if the source object actually has the notated property;\n     *  and getting its value if exists.\n     *  @param {String} notation - The notation string to be inspected.\n     *  @returns {InspectResult} - The result object.\n     *\n     *  @example\n     *  Notation.create({ car: { year: 1970 } }).inspect(\"car.year\");\n     *  // { has: true, value: 1970, lastNote: 'year', lastNoteNormalized: 'year' }\n     *  Notation.create({ car: { year: 1970 } }).inspect(\"car.color\");\n     *  // { has: false }\n     *  Notation.create({ car: { color: undefined } }).inspect(\"car.color\");\n     *  // { has: true, value: undefined, lastNote: 'color', lastNoteNormalized: 'color' }\n     *  Notation.create({ car: { brands: ['Ford', 'Dodge'] } }).inspect(\"car.brands[1]\");\n     *  // { has: true, value: 'Dodge', lastNote: '[1]', lastNoteNormalized: 1 }\n     */\n    inspect(notation) {\n        let level = this._source;\n        let result = { has: false, value: undefined };\n        let parent;\n        Notation.eachNote(notation, (levelNotation, note) => {\n            const lastNoteNormalized = utils.normalizeNote(note);\n            if (utils.hasOwn(level, lastNoteNormalized)) {\n                level = level[lastNoteNormalized];\n                parent = level;\n                result = {\n                    notation,\n                    has: true,\n                    value: level,\n                    lastNote: note,\n                    lastNoteNormalized\n                };\n            } else {\n                // level = undefined;\n                result = {\n                    notation,\n                    has: false,\n                    lastNote: note,\n                    lastNoteNormalized\n                };\n                return false; // break out\n            }\n        });\n\n        if (parent === undefined || (result.has && parent === result.value)) parent = this._source;\n        result.parentIsArray = utils.type(parent) === 'array';\n\n        return result;\n    }\n\n    /**\n     *  Notation inspection result object.\n     *  @typedef Notation~InspectResult\n     *  @type Object\n     *  @property {String} notation - Notation that is inspected.\n     *  @property {Boolean} has - Indicates whether the source object has the\n     *  given notation as a (leveled) enumerable property. If the property\n     *  exists but has a value of `undefined`, this will still return `true`.\n     *  @property {*} value - The value of the notated property. If the source\n     *  object does not have the notation, the value will be `undefined`.\n     *  @property {String} lastNote - Last note of the notation, if actually\n     *  exists. For example, last note of `'a.b.c'` is `'c'`.\n     *  @property {String|Number} lastNoteNormalized - Normalized representation\n     *  of the last note of the notation, if actually exists. For example, last\n     *  note of `'a.b[1]` is `'[1]'` and will be normalized to number `1`; which\n     *  indicates an array index.\n     *  @property {Boolean} parentIsArray - Whether the parent object of the\n     *  notation path is an array.\n     */\n\n    /**\n     *  Inspects and removes the given notation from the source object by\n     *  checking if the source object actually has the notated property; and\n     *  getting its value if exists, before removing the property.\n     *\n     *  @param {String} notation - The notation string to be inspected.\n     *\n     *  @returns {InspectResult} - The result object.\n     *\n     *  @example\n     *  let obj = { name: \"John\", car: { year: 1970 } };\n     *  let result = Notation.create(obj).inspectRemove(\"car.year\");\n     *  // result  { notation: \"car.year\", has: true, value: 1970, lastNote: \"year\", lastNoteNormalized: \"year\" }\n     *  // obj  { name: \"John\", car: {} }\n     *\n     *  result = Notation.create({ car: { year: 1970 } }).inspectRemove(\"car.color\");\n     *  // result  { notation: \"car.color\", has: false }\n     *  Notation.create({ car: { color: undefined } }).inspectRemove(\"car['color']\");\n     *  // { notation: \"car.color\", has: true, value: undefined, lastNote: \"['color']\", lastNoteNormalized: \"color\" }\n     *\n     *  let obj = { car: { colors: [\"black\", \"white\"] } };\n     *  let result = Notation.create().inspectRemove(\"car.colors[0]\");\n     *  // result  { notation: \"car.colors[0]\", has: true, value: \"black\", lastNote: \"[0]\", lastNoteNormalized: 0 }\n     *  // obj  { car: { colors: [(empty), \"white\"] } }\n     */\n    inspectRemove(notation) {\n        if (!notation) throw new Error(ERR.NOTATION + `'${notation}'`);\n        const parentNotation = Notation.parent(notation);\n        const parent = parentNotation ? this.get(parentNotation, null) : this._source;\n        const parentIsArray = utils.type(parent) === 'array';\n        const lastNote = Notation.last(notation);\n        const lastNoteNormalized = utils.normalizeNote(lastNote);\n\n        let result;\n        if (utils.hasOwn(parent, lastNoteNormalized)) {\n            result = {\n                notation,\n                has: true,\n                value: parent[lastNoteNormalized],\n                lastNote,\n                lastNoteNormalized,\n                parentIsArray\n            };\n\n            // if `preserveIndices` is enabled and this is an array, we'll\n            // splice the item out. otherwise, we'll use `delete` syntax to\n            // empty the item.\n            if (!this.options.preserveIndices && parentIsArray) {\n                parent.splice(lastNoteNormalized, 1);\n            } else {\n                delete parent[lastNoteNormalized];\n            }\n        } else {\n            result = {\n                notation,\n                has: false,\n                lastNote,\n                lastNoteNormalized,\n                parentIsArray\n            };\n        }\n\n        return result;\n    }\n\n    /**\n     *  Checks whether the source object has the given notation\n     *  as a (leveled) enumerable property. If the property exists\n     *  but has a value of `undefined`, this will still return `true`.\n     *  @param {String} notation - The notation string to be checked.\n     *  @returns {Boolean} -\n     *\n     *  @example\n     *  Notation.create({ car: { year: 1970 } }).has(\"car.year\"); // true\n     *  Notation.create({ car: { year: undefined } }).has(\"car.year\"); // true\n     *  Notation.create({}).has(\"car.color\"); // false\n     */\n    has(notation) {\n        return this.inspect(notation).has;\n    }\n\n    /**\n     *  Checks whether the source object has the given notation\n     *  as a (leveled) defined enumerable property. If the property\n     *  exists but has a value of `undefined`, this will return `false`.\n     *  @param {String} notation - The notation string to be checked.\n     *  @returns {Boolean} -\n     *\n     *  @example\n     *  Notation.create({ car: { year: 1970 } }).hasDefined(\"car.year\"); // true\n     *  Notation.create({ car: { year: undefined } }).hasDefined(\"car.year\"); // false\n     *  Notation.create({}).hasDefined(\"car.color\"); // false\n     */\n    hasDefined(notation) {\n        return this.inspect(notation).value !== undefined;\n    }\n\n    /**\n     *  Gets the value of the corresponding property at the given notation.\n     *\n     *  @param {String} notation - The notation string to be processed.\n     *  @param {String} [defaultValue] - The default value to be returned if the\n     *  property is not found or enumerable.\n     *\n     *  @returns {*} - The value of the notated property.\n     *  @throws {NotationError} - If `strict` option is enabled, `defaultValue`\n     *  is not set and notation does not exist.\n     *\n     *  @example\n     *  Notation.create({ car: { brand: \"Dodge\" } }).get(\"car.brand\"); // \"Dodge\"\n     *  Notation.create({ car: {} }).get(\"car.model\", \"Challenger\"); // \"Challenger\"\n     *  Notation.create({ car: { model: undefined } }).get(\"car.model\", \"Challenger\"); // undefined\n     *\n     *  @example <caption>get value when strict option is enabled</caption>\n     *  // strict option defaults to false\n     *  Notation.create({ car: {} }).get(\"car.model\"); // undefined\n     *  Notation.create({ car: {} }, { strict: false }).get(\"car.model\"); // undefined\n     *  // below will throw bec. strict = true, car.model does not exist\n     *  // and no default value is given.\n     *  Notation.create({ car: {} }, { strict: true }).get(\"car.model\");\n     */\n    get(notation, defaultValue) {\n        const result = this.inspect(notation);\n        // if strict and no default value is set, check if implied index or prop\n        // exists\n        if (this.options.strict && arguments.length < 2 && !result.has) {\n            const msg = result.parentIsArray ? ERR.NO_INDEX : ERR.NO_PROP;\n            throw new NotationError(msg + `'${notation}'`);\n        }\n        return result.has ? result.value : defaultValue;\n    }\n\n    /**\n     *  Sets the value of the corresponding property at the given notation. If\n     *  the property does not exist, it will be created and nested at the\n     *  calculated level. If it exists; its value will be overwritten by\n     *  default.\n     *  @chainable\n     *\n     *  @param {String} notation - The notation string to be processed.\n     *  @param {*} value - The value to be set for the notated property.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property if\n     *  exists.\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @throws {NotationError} - If strict notation is enabled, `overwrite`\n     *  option is set to `false` and attempted to overwrite an existing value.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", year: 1970 } };\n     *  Notation.create(obj)\n     *      .set(\"car.brand\", \"Ford\")\n     *      .set(\"car.model\", \"Mustang\")\n     *      .set(\"car.year\", 1965, false)\n     *      .set(\"car.color\", \"red\")\n     *      .set(\"boat\", \"none\");\n     *  console.log(obj);\n     *  // { notebook: \"Mac\", car: { brand: \"Ford\", model: \"Mustang\", year: 1970, color: \"red\" }, boat: \"none\" };\n     */\n    set(notation, value, overwrite = true) {\n        if (!notation.trim()) throw new NotationError(ERR.NOTATION + `'${notation}'`);\n\n        let level = this._source;\n        let currentIsLast, nCurrentNote, nNextNote, nextIsArrayNote;\n\n        Notation.eachNote(notation, (levelNotation, note, index, list) => {\n            currentIsLast = index === list.length - 1;\n            nCurrentNote = nNextNote || utils.normalizeNote(note);\n            nNextNote = currentIsLast ? null : utils.normalizeNote(list[index + 1]);\n\n            if (utils.type(level) === 'array' && typeof nCurrentNote !== 'number') {\n                const parent = Notation.parent(levelNotation) || 'source';\n                throw new NotationError(`Cannot set string key '${note}' on array ${parent}`);\n            }\n\n            // check if the property is at this level\n            if (utils.hasOwn(level, nCurrentNote)) {\n                // check if we're at the last level\n                if (currentIsLast) {\n                    // if overwrite is set, assign the value.\n                    if (overwrite) {\n                        level[nCurrentNote] = value;\n                    } else if (this.options.strict) {\n                        throw new NotationError('Cannot overwrite an existing value in strict mode.');\n                    }\n                } else {\n                    // if not, just re-reference the current level.\n                    level = level[nCurrentNote];\n                }\n            } else {\n                // if next normalized note is a number, it indicates that the\n                // current note is actually an array.\n                nextIsArrayNote = typeof nNextNote === 'number';\n\n                // we don't have this property at this level so; if this is the\n                // last level, we set the value if not, we set an empty\n                // collection for the next level\n                level[nCurrentNote] = (currentIsLast ? value : (nextIsArrayNote ? [] : {}));\n                level = level[nCurrentNote];\n            }\n        });\n        return this;\n    }\n\n    /**\n     *  Just like the `.set()` method but instead of a single notation\n     *  string, an object of notations and values can be passed.\n     *  Sets the value of each corresponding property at the given\n     *  notation. If a property does not exist, it will be created\n     *  and nested at the calculated level. If it exists; its value\n     *  will be overwritten by default.\n     *  @chainable\n     *\n     *  @param {Object} notationsObject - The notations object to be processed.\n     *  This can either be a regular object with non-dotted keys\n     *  (which will be merged to the first/root level of the source object);\n     *  or a flattened object with notated (dotted) keys.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite a property if\n     *  exists.\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", year: 1970 } };\n     *  Notation.create(obj).merge({\n     *      \"car.brand\": \"Ford\",\n     *      \"car.model\": \"Mustang\",\n     *      \"car.year\": 1965,\n     *      \"car.color\": \"red\",\n     *      \"boat\": \"none\"\n     *  });\n     *  console.log(obj);\n     *  // { car: { brand: \"Ford\", model: \"Mustang\", year: 1970, color: \"red\" }, boat: \"none\" };\n     */\n    merge(notationsObject, overwrite = true) {\n        if (utils.type(notationsObject) !== 'object') {\n            throw new NotationError(ERR.NOTA_OBJ + 'Expected an object.');\n        }\n        let value;\n        utils.each(Object.keys(notationsObject), notation => {\n            value = notationsObject[notation];\n            this.set(notation, value, overwrite);\n        });\n        return this;\n    }\n\n    /**\n     *  Removes the properties by the given list of notations from the source\n     *  object and returns a new object with the removed properties.\n     *  Opposite of `merge()` method.\n     *\n     *  @param {Array} notations - The notations array to be processed.\n     *\n     *  @returns {Object} - An object with the removed properties.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", year: 1970 }, notebook: \"Mac\" };\n     *  const separated = Notation.create(obj).separate([\"car.brand\", \"boat\" ]);\n     *  console.log(separated);\n     *  // { notebook: \"Mac\", car: { brand: \"Ford\" } };\n     *  console.log(obj);\n     *  // { car: { year: 1970 } };\n     */\n    separate(notations) {\n        if (utils.type(notations) !== 'array') {\n            throw new NotationError(ERR.NOTA_OBJ + 'Expected an array.');\n        }\n        const o = new Notation({});\n        utils.each(notations, notation => {\n            const result = this.inspectRemove(notation);\n            o.set(notation, result.value);\n        });\n        this._source = o._source;\n        return this;\n    }\n\n    /**\n     *  Deep clones the source object while filtering its properties by the\n     *  given <b>glob</b> notations. Includes all matched properties and removes\n     *  the rest.\n     *\n     *  The difference between regular notations and glob-notations is that;\n     *  with the latter, you can use wildcard stars (*) and negate the notation\n     *  by prepending a bang (!). A negated notation will be excluded.\n     *\n     *  Order of the globs does not matter; they will be logically sorted. Loose\n     *  globs will be processed first and verbose globs or normal notations will\n     *  be processed last. e.g. `[ \"car.model\", \"*\", \"!car.*\" ]` will be\n     *  normalized and sorted as `[ \"*\", \"!car\" ]`.\n     *\n     *  Passing no parameters or passing an empty string (`\"\"` or `[\"\"]`) will\n     *  empty the source object. See `Notation.Glob` class for more information.\n     *  @chainable\n     *\n     *  @param {Array|String} globList - Glob notation list to be processed.\n     *  @param {Boolean} [restrictive=false] - Whether negated items strictly\n     *  remove every match. Note that, regardless of this option, if any item has an\n     *  exact negated version; non-negated is always removed.\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self). To\n     *  get the filtered value, call `.value` property on the instance.\n     *\n     *  @example\n     *  const source = { notebook: \"Mac\", car: { brand: \"Ford\", model: \"Mustang\", year: 1970 } };\n     *  const n = Notation.create(source);\n     *  n.filter([ \"*\", \"!car.year\" ])\n     *  console.log(source)          // { notebook: \"Mac\", car: { brand: \"Ford\", model: \"Mustang\" } }\n     *  n.filter(\"car.brand\").value  // { car: { brand: \"Ford\" } }\n     *  console.log(source)          // { notebook: \"Mac\", car: { model: \"Mustang\" } }\n     *  n.filter().value             // {} //  equivalent to n.filter(\"\") or n.filter(\"!*\")\n     */\n    filter(globList, restrictive = false) {\n        const { re } = utils;\n\n        // ensure array, normalize and sort the globs in logical order. this\n        // also concats the array first (to prevent mutating the original\n        // array).\n        const globs = NotationGlob.normalize(globList, restrictive);\n        const len = globs.length;\n        const empty = this._isArray ? [] : {};\n\n        // if globs is \"\" or [\"\"] or [\"!*\"] set source to empty and return.\n        if (len === 0 || (len === 1 && (!globs[0] || re.NEGATE_ALL.test(globs[0])))) {\n            this._source = empty;\n            return this;\n        }\n\n        const original = this.value;\n        const copy = utils.deepCopy(original);\n\n        const firstIsWildcard = re.WILDCARD.test(globs[0]);\n        // if globs only consist of \"*\" or \"[*]\"; set the \"copy\" as source and\n        // return.\n        if (len === 1 && firstIsWildcard) {\n            this._source = copy;\n            return this;\n        }\n\n        let filtered;\n        // if the first item of sorted globs is \"*\" or \"[*]\" we set the source\n        // to the (full) \"copy\" and remove the wildcard from globs (not to\n        // re-process).\n        if (firstIsWildcard) {\n            filtered = new Notation(copy);\n            globs.shift();\n        } else {\n            // otherwise we set an empty object or array as the source so that\n            // we can add notations/properties to it.\n            filtered = new Notation(empty);\n        }\n\n        let g, endStar, normalized;\n        // iterate through globs\n        utils.each(globs, globNotation => {\n            g = new NotationGlob(globNotation);\n            // set flag that indicates whether the glob ends with `.*`\n            endStar = g.absGlob.slice(-2) === '.*';\n            // get the remaining part as the (extra) normalized glob\n            normalized = endStar ? g.absGlob.slice(0, -2) : g.absGlob;\n            // normalized = endStar ? g.absGlob.replace(/(\\.\\*)+$/, '') : g.absGlob;\n            // check if normalized glob has no wildcard stars e.g. \"a.b\" or\n            // \"!a.b.c\" etc..\n            if (normalized.indexOf('*') < 0) {\n                if (g.isNegated) {\n                    // directly remove the notation if negated\n                    filtered.remove(normalized);\n                    // if original glob had `.*` at the end, it means remove\n                    // contents (not itself). so we'll set an empty object.\n                    // meaning `some.prop` (prop) is removed completely but\n                    // `some.prop.*` (prop) results in `{}`.\n                    if (endStar) filtered.set(normalized, {}, true);\n                } else {\n                    // directly copy the same notation from the original\n                    filtered.copyFrom(original, normalized, null, true);\n                }\n                // move to the next\n                return true;\n            }\n            // if glob has wildcard star(s), we'll iterate through keys of the\n            // source object and see if (full) notation of each key matches\n            // the current glob.\n\n            // TODO: Optimize the loop below. Instead of checking each key's\n            // notation, get the non-star left part of the glob and iterate\n            // that property of the source object.\n            this.each((originalNotation, key, value) => {\n                // console.log('>>', originalNotation);\n\n                // iterating each note of original notation. i.e.:\n                // note1.note2.note3 is iterated from left to right, as:\n                // 'note1', 'note1.note2', 'note1.note2.note3'  in order.\n                Notation.eachNote(originalNotation, levelNotation => {\n                    if (g.test(levelNotation)) {\n                        if (g.isNegated) {\n                            // console.log('removing', levelNotation, 'of', originalNotation);\n                            filtered.remove(levelNotation);\n                            // we break and return early if removed bec. e.g.\n                            // when 'note1.note2' of 'note1.note2.note3' is\n                            // also removed, we no more have 'note3'.\n                            return false;\n                        }\n                        filtered.set(levelNotation, value, true);\n                    }\n                });\n            });\n        });\n        // finally set the filtered's value as the source of our instance and\n        // return.\n        this._source = filtered.value;\n        return this;\n    }\n\n    /**\n     *  Removes the property from the source object, at the given notation.\n     *  @alias Notation#delete\n     *  @chainable\n     *  @param {String} notation - The notation to be inspected.\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *  @throws {NotationError} - If `strict` option is enabled and notation\n     *  does not exist.\n     *\n     *  @example\n     *  const obj = { notebook: \"Mac\", car: { model: \"Mustang\" } };\n     *  Notation.create(obj).remove(\"car.model\");\n     *  console.log(obj); // { notebook: \"Mac\", car: { } }\n     */\n    remove(notation) {\n        const result = this.inspectRemove(notation);\n        // if strict, check if implied index or prop exists\n        if (this.options.strict && !result.has) {\n            const msg = result.parentIsArray ? ERR.NO_INDEX : ERR.NO_PROP;\n            throw new NotationError(msg + `'${notation}'`);\n        }\n        return this;\n    }\n\n    /**\n     *  Alias of `Notation#remove`\n     *  @private\n     *  @param {String} notation -\n     *  @returns {Notation} -\n     */\n    delete(notation) {\n        this.remove(notation);\n        return this;\n    }\n\n    /**\n     *  Clones the `Notation` instance to a new one.\n     *  @returns {Notation} - A new copy of the instance.\n     */\n    clone() {\n        return new Notation(utils.deepCopy(this.value));\n    }\n\n    /**\n     *  Copies the notated property from the source collection and adds it to the\n     *  destination  only if the source object actually has that property.\n     *  This is different than a property with a value of `undefined`.\n     *  @chainable\n     *\n     *  @param {Object|Array} destination - The destination object that the notated\n     *  properties will be copied to.\n     *  @param {String} notation - The notation to get the corresponding property\n     *  from the source object.\n     *  @param {String} [newNotation=null] - The notation to set the source property\n     *  on the destination object. In other words, the copied property will be\n     *  renamed to this value before set on the destination object. If not set,\n     *  `notation` argument will be used.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property on\n     *  the destination object if it exists.\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @throws {NotationError} - If `destination` is not a valid collection.\n     *  @throws {NotationError} - If `notation` or `newNotation` is invalid.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  const models = { dodge: \"Charger\" };\n     *  Notation.create(obj).copyTo(models, \"car.model\", \"ford\");\n     *  console.log(models);\n     *  // { dodge: \"Charger\", ford: \"Mustang\" }\n     *  // source object (obj) is not modified\n     */\n    copyTo(destination, notation, newNotation = null, overwrite = true) {\n        if (!utils.isCollection(destination)) throw new NotationError(ERR.DEST);\n        const result = this.inspect(notation);\n        if (result.has) {\n            const newN = utils.getNewNotation(newNotation, notation);\n            new Notation(destination).set(newN, result.value, overwrite);\n        }\n        return this;\n    }\n\n    /**\n     *  Copies the notated property from the target collection and adds it to\n     *  (own) source object  only if the target object actually has that\n     *  property. This is different than a property with a value of `undefined`.\n     *  @chainable\n     *\n     *  @param {Object|Array} target - The target collection that the notated\n     *  properties will be copied from.\n     *  @param {String} notation - The notation to get the corresponding\n     *  property from the target object.\n     *  @param {String} [newNotation=null] - The notation to set the copied\n     *  property on our source collection. In other words, the copied property\n     *  will be renamed to this value before set. If not set, `notation`\n     *  argument will be used.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property on\n     *  our collection if it exists.\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @throws {NotationError} - If `target` is not a valid collection.\n     *  @throws {NotationError} - If `notation` or `newNotation` is invalid.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  const models = { dodge: \"Charger\" };\n     *  Notation.create(obj).copyFrom(models, \"dodge\", \"car.model\", true);\n     *  console.log(obj);\n     *  // { car: { brand: \"Ford\", model: \"Charger\" } }\n     *  // models object is not modified\n     */\n    copyFrom(target, notation, newNotation = null, overwrite = true) {\n        if (!utils.isCollection(target)) throw new NotationError(ERR.DEST);\n        const result = new Notation(target).inspect(notation);\n        if (result.has) {\n            const newN = utils.getNewNotation(newNotation, notation);\n            this.set(newN, result.value, overwrite);\n        }\n        return this;\n    }\n\n    /**\n     *  Removes the notated property from the source (own) collection and adds\n     *  it to the destination  only if the source collection actually has that\n     *  property. This is different than a property with a value of `undefined`.\n     *  @chainable\n     *\n     *  @param {Object|Array} destination - The destination collection that the\n     *  notated properties will be moved to.\n     *  @param {String} notation - The notation to get the corresponding\n     *  property from the source object.\n     *  @param {String} [newNotation=null] - The notation to set the source\n     *  property on the destination object. In other words, the moved property\n     *  will be renamed to this value before set on the destination object. If\n     *  not set, `notation` argument will be used.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property on\n     *  the destination object if it exists.\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @throws {NotationError} - If `destination` is not a valid collection.\n     *  @throws {NotationError} - If `notation` or `newNotation` is invalid.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  const models = { dodge: \"Charger\" };\n     *  Notation.create(obj).moveTo(models, \"car.model\", \"ford\");\n     *  console.log(obj);\n     *  // { car: { brand: \"Ford\" } }\n     *  console.log(models);\n     *  // { dodge: \"Charger\", ford: \"Mustang\" }\n     */\n    moveTo(destination, notation, newNotation = null, overwrite = true) {\n        if (!utils.isCollection(destination)) throw new NotationError(ERR.DEST);\n        const result = this.inspectRemove(notation);\n        if (result.has) {\n            const newN = utils.getNewNotation(newNotation, notation);\n            new Notation(destination).set(newN, result.value, overwrite);\n        }\n        return this;\n    }\n\n    /**\n     *  Removes the notated property from the target collection and adds it to (own)\n     *  source collection  only if the target object actually has that property.\n     *  This is different than a property with a value of `undefined`.\n     *  @chainable\n     *\n     *  @param {Object|Array} target - The target collection that the notated\n     *  properties will be moved from.\n     *  @param {String} notation - The notation to get the corresponding property\n     *  from the target object.\n     *  @param {String} [newNotation=null] - The notation to set the target\n     *  property on the source object. In other words, the moved property\n     *  will be renamed to this value before set on the source object.\n     *  If not set, `notation` argument will be used.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property on\n     *  the source object if it exists.\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @throws {NotationError} - If `target` is not a valid collection.\n     *  @throws {NotationError} - If `notation` or `newNotation` is invalid.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  const models = { dodge: \"Charger\" };\n     *  Notation.create(obj).moveFrom(models, \"dodge\", \"car.model\", true);\n     *  console.log(obj);\n     *  // { car: { brand: \"Ford\", model: \"Charger\" } }\n     *  console.log(models);\n     *  // {}\n     */\n    moveFrom(target, notation, newNotation = null, overwrite = true) {\n        if (!utils.isCollection(target)) throw new NotationError(ERR.DEST);\n        const result = new Notation(target).inspectRemove(notation);\n        if (result.has) {\n            const newN = utils.getNewNotation(newNotation, notation);\n            this.set(newN, result.value, overwrite);\n        }\n        return this;\n    }\n\n    /**\n     *  Renames the notated property of the source collection by the new notation.\n     *  @alias Notation#renote\n     *  @chainable\n     *\n     *  @param {String} notation - The notation to get the corresponding\n     *  property (value) from the source collection.\n     *  @param {String} newNotation - The new notation for the targeted\n     *  property value. If not set, the source collection will not be modified.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property at\n     *  the new notation, if it exists.\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @throws {NotationError} - If `notation` or `newNotation` is invalid.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  Notation.create(obj)\n     *      .rename(\"car.brand\", \"carBrand\")\n     *      .rename(\"car.model\", \"carModel\");\n     *  console.log(obj);\n     *  // { carBrand: \"Ford\", carModel: \"Mustang\" }\n     */\n    rename(notation, newNotation, overwrite) {\n        return this.moveTo(this._source, notation, newNotation, overwrite);\n    }\n\n    /**\n     *  Alias for `#rename`\n     *  @private\n     *  @param {String} notation -\n     *  @param {String} newNotation -\n     *  @param {Boolean} [overwrite=true] -\n     *  @returns {Notation} -\n     */\n    renote(notation, newNotation, overwrite) {\n        return this.rename(notation, newNotation, overwrite);\n    }\n\n    /**\n     *  Extracts the property at the given notation to a new object by copying\n     *  it from the source collection. This is equivalent to `.copyTo({},\n     *  notation, newNotation)`.\n     *  @alias Notation#copyToNew\n     *\n     *  @param {String} notation - The notation to get the corresponding\n     *  property (value) from the source object.\n     *  @param {String} newNotation - The new notation to be set on the new\n     *  object for the targeted property value. If not set, `notation` argument\n     *  will be used.\n     *\n     *  @returns {Object} - Returns a new object with the notated property.\n     *\n     *  @throws {NotationError} - If `notation` or `newNotation` is invalid.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  const extracted = Notation.create(obj).extract(\"car.brand\", \"carBrand\");\n     *  console.log(extracted);\n     *  // { carBrand: \"Ford\" }\n     *  // obj is not modified\n     */\n    extract(notation, newNotation) {\n        const o = {};\n        this.copyTo(o, notation, newNotation);\n        return o;\n    }\n\n    /**\n     *  Alias for `#extract`\n     *  @private\n     *  @param {String} notation -\n     *  @param {String} newNotation -\n     *  @returns {Object} -\n     */\n    copyToNew(notation, newNotation) {\n        return this.extract(notation, newNotation);\n    }\n\n    /**\n     *  Extrudes the property at the given notation to a new collection by\n     *  moving it from the source collection. This is equivalent to `.moveTo({},\n     *  notation, newNotation)`.\n     *  @alias Notation#moveToNew\n     *\n     *  @param {String} notation - The notation to get the corresponding\n     *  property (value) from the source object.\n     *  @param {String} newNotation - The new notation to be set on the new\n     *  object for the targeted property value. If not set, `notation` argument\n     *  will be used.\n     *\n     *  @returns {Object} - Returns a new object with the notated property.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  const extruded = Notation.create(obj).extrude(\"car.brand\", \"carBrand\");\n     *  console.log(obj);\n     *  // { car: { model: \"Mustang\" } }\n     *  console.log(extruded);\n     *  // { carBrand: \"Ford\" }\n     */\n    extrude(notation, newNotation) {\n        const o = {};\n        this.moveTo(o, notation, newNotation);\n        return o;\n    }\n\n    /**\n     *  Alias for `#extrude`\n     *  @private\n     *  @param {String} notation -\n     *  @param {String} newNotation -\n     *  @returns {Object} -\n     */\n    moveToNew(notation, newNotation) {\n        return this.extrude(notation, newNotation);\n    }\n\n    // --------------------------------\n    // STATIC MEMBERS\n    // --------------------------------\n\n    /**\n     *  Basically constructs a new `Notation` instance.\n     *  @chainable\n     *  @param {Object|Array} [source={}] - The source collection to be notated.\n     *  @param {Object} [options] - Notation options.\n     *      @param {Boolean} [options.strict=false] - Whether to throw when a\n     *      notation path does not exist on the source. (Note that `.inspect()`\n     *      and `.inspectRemove()` methods are exceptions). It's recommended to\n     *      set this to `true` and prevent silent failures if you're working\n     *      with sensitive data. Regardless of `strict` option, it will always\n     *      throw on invalid notation syntax or other crucial failures.\n     *      @param {Boolean} [options.preserveIndices=true] - Indicates whether to\n     *      preserve the indices of the parent array when an item is to be removed.\n     *      By default indices are preserved by emptying the item (sparse array),\n     *      instead of removing the item completely at the index. When this is\n     *      disabled; you should mind the shifted indices when you remove an\n     *      item via `.remove()`, `.inspectRemove()` or `.filter()`.\n     *\n     *  @returns {Notation} - The created instance.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  const notation = Notation.create(obj); // equivalent to new Notation(obj)\n     *  notation.get('car.model')   //  \"Charger\"\n     *  notation.remove('car.model').set('car.color', 'red').value\n     *  //  { car: { brand: \"Dodge\", year: 1970, color: \"red\" } }\n     */\n    static create(source, options) {\n        if (arguments.length === 0) {\n            return new Notation({});\n        }\n        return new Notation(source, options);\n    }\n\n    /**\n     *  Checks whether the given notation string is valid. Note that the star\n     *  (`*`) (which is a valid character, even if irregular) is NOT treated as\n     *  wildcard here. This checks for regular dot-notation, not a glob-notation.\n     *  For glob notation validation, use `Notation.Glob.isValid()` method. Same\n     *  goes for the negation character/prefix (`!`).\n     *\n     *  @param {String} notation - The notation string to be checked.\n     *  @returns {Boolean} -\n     *\n     *  @example\n     *  Notation.isValid('prop1.prop2.prop3'); // true\n     *  Notation.isValid('x'); // true\n     *  Notation.isValid('x.arr[0].y'); // true\n     *  Notation.isValid('x[\"*\"]'); // true\n     *  Notation.isValid('x.*'); // false (this would be valid for Notation#filter() only or Notation.Glob class)\n     *  Notation.isValid('@1'); // false (should be \"['@1']\")\n     *  Notation.isValid(null); // false\n     */\n    static isValid(notation) {\n        return typeof notation === 'string' && reVALIDATOR.test(notation);\n    }\n\n    /**\n     *  Splits the given notation string into its notes (levels).\n     *  @param {String} notation  Notation string to be splitted.\n     *  @returns {Array} - A string array of notes (levels).\n     *  @throws {NotationError} - If given notation is invalid.\n     */\n    static split(notation) {\n        if (!Notation.isValid(notation)) {\n            throw new NotationError(ERR.NOTATION + `'${notation}'`);\n        }\n        return notation.match(reMATCHER);\n    }\n\n    /**\n     *  Joins the given notes into a notation string.\n     *  @param {String} notes  Notes (levels) to be joined.\n     *  @returns {String}  Joined notation string.\n     */\n    static join(notes) {\n        return utils.joinNotes(notes);\n    }\n\n    /**\n     *  Counts the number of notes/levels in the given notation.\n     *  @alias Notation.countLevels\n     *  @param {String} notation - The notation string to be processed.\n     *  @returns {Number} - Number of notes.\n     *  @throws {NotationError} - If given notation is invalid.\n     */\n    static countNotes(notation) {\n        return Notation.split(notation).length;\n    }\n\n    /**\n     *  Alias of `Notation.countNotes`.\n     *  @private\n     *  @param {String} notation -\n     *  @returns {Number} -\n     */\n    static countLevels(notation) {\n        return Notation.countNotes(notation);\n    }\n\n    /**\n     *  Gets the first (root) note of the notation string.\n     *  @param {String} notation - The notation string to be processed.\n     *  @returns {String} - First note.\n     *  @throws {NotationError} - If given notation is invalid.\n     *\n     *  @example\n     *  Notation.first('first.prop2.last'); // \"first\"\n     */\n    static first(notation) {\n        return Notation.split(notation)[0];\n    }\n\n    /**\n     *  Gets the last note of the notation string.\n     *  @param {String} notation - The notation string to be processed.\n     *  @returns {String} - Last note.\n     *  @throws {NotationError} - If given notation is invalid.\n     *\n     *  @example\n     *  Notation.last('first.prop2.last'); // \"last\"\n     */\n    static last(notation) {\n        const list = Notation.split(notation);\n        return list[list.length - 1];\n    }\n\n    /**\n     *  Gets the parent notation (up to but excluding the last note)\n     *  from the notation string.\n     *  @param {String} notation - The notation string to be processed.\n     *  @returns {String} - Parent note if any. Otherwise, `null`.\n     *  @throws {NotationError} - If given notation is invalid.\n     *\n     *  @example\n     *  Notation.parent('first.prop2.last'); // \"first.prop2\"\n     *  Notation.parent('single'); // null\n     */\n    static parent(notation) {\n        const last = Notation.last(notation);\n        return notation.slice(0, -last.length).replace(/\\.$/, '') || null;\n    }\n\n    /**\n     *  Iterates through each note/level of the given notation string.\n     *  @alias Notation.eachLevel\n     *\n     *  @param {String} notation - The notation string to be iterated through.\n     *  @param {Function} callback - The callback function to be invoked on\n     *  each iteration. To break out of the loop, return `false` from within the\n     *  callback.\n     *  Callback signature: `callback(levelNotation, note, index, list) { ... }`\n     *\n     *  @returns {void}\n     *  @throws {NotationError} - If given notation is invalid.\n     *\n     *  @example\n     *  const notation = 'first.prop2.last';\n     *  Notation.eachNote(notation, function (levelNotation, note, index, list) {\n     *      console.log(index, note, levelNotation);\n     *  });\n     *  // 0  \"first\"             \"first\"\n     *  // 1  \"first.prop2\"       \"prop2\"\n     *  // 2  \"first.prop2.last\"  \"last\"\n     */\n    static eachNote(notation, callback) {\n        const notes = Notation.split(notation);\n        const levelNotes = [];\n        utils.each(notes, (note, index) => {\n            levelNotes.push(note);\n            if (callback(Notation.join(levelNotes), note, index, notes) === false) return false;\n        }, Notation);\n    }\n\n    /**\n     *  Alias of `Notation.eachNote`.\n     *  @private\n     *  @param {String} notation -\n     *  @param {Function} callback -\n     *  @returns {void}\n     */\n    static eachLevel(notation, callback) {\n        Notation.eachNote(notation, callback);\n    }\n\n}\n\n/**\n *  Error class specific to `Notation`.\n *  @private\n *\n *  @class\n *  @see `{@link #Notation.Error}`\n */\nNotation.Error = NotationError;\n\n/**\n *  Utility for validating, comparing and sorting dot-notation globs.\n *  This is internally used by `Notation` class.\n *  @private\n *\n *  @class\n *  @see `{@link #Notation.Glob}`\n */\nNotation.Glob = NotationGlob;\n\n/**\n *  Undocumented\n *  @private\n */\nNotation.utils = utils;\n\n// --------------------------------\n// HELPERS\n// --------------------------------\n\n/**\n *  Deep iterates through each note (level) of each item in the given\n *  collection.\n *  @private\n *  @param {Object|Array} collection  A data object or an array, as the source.\n *  @param {Function} callback  A function to be executed on each iteration,\n *  with the following arguments: `(levelNotation, note, value, collection)`\n *  @param {String} parentNotation  Storage for parent (previous) notation.\n *  @param {Collection} topSource  Storage for initial/main collection.\n *  @param {Boolean} [byLevel=false]  Indicates whether to iterate notations by\n *  each level or by the end value.  For example, if we have a collection of\n *  `{a: { b: true } }`, and `byLevel` is set; the callback will be invoked on\n *  the following notations: `a`, `a.b`. Otherwise, it will be invoked only on\n *  `a.b`.\n *  @returns {void}\n */\nfunction _each(collection, callback, parentNotation, topSource, byLevel = false) { // eslint-disable-line max-params\n    const source = topSource || collection;\n    // if (!utils.isCollection(collection)) throw ... // no need\n    utils.eachItem(collection, (value, keyOrIndex) => {\n        const note = typeof keyOrIndex === 'number'\n            ? `[${keyOrIndex}]`\n            : keyOrIndex;\n        const currentNotation = Notation.join([parentNotation, note]);\n        const isCollection = utils.isCollection(value);\n        // if it's not a collection we'll execute the callback. if it's a\n        // collection but byLevel is set, we'll also execute the callback.\n        if (!isCollection || byLevel) {\n            if (callback(currentNotation, note, value, source) === false) return false;\n        }\n        // deep iterating if collection\n        if (isCollection) _each(value, callback, currentNotation, source, byLevel);\n    });\n}\n\n// --------------------------------\n// EXPORT\n// --------------------------------\n\nexport { Notation };\n","/* istanbul ignore file */\nexport * from './core/notation';\n","\nimport { NotationError } from './core/notation.error';\n\nconst objProto = Object.prototype;\nconst symValueOf = Symbol.prototype.valueOf;\n\n// never use 'g' (global) flag in regexps below\nconst VAR = /^[a-z$_][a-z$_\\d]*$/i;\nconst ARRAY_NOTE = /^\\[(\\d+)\\]$/;\nconst ARRAY_GLOB_NOTE = /^\\[(\\d+|\\*)\\]$/;\nconst OBJECT_BRACKETS = /^\\[(?:'(.*)'|\"(.*)\"|`(.*)`)\\]$/;\nconst WILDCARD = /^(\\[\\*\\]|\\*)$/;\n// matches `*` and `[*]` if outside of quotes.\nconst WILDCARDS = /(\\*|\\[\\*\\])(?=(?:[^\"]|\"[^\"]*\")*$)(?=(?:[^']|'[^']*')*$)/;\n// matches trailing wildcards at the end of a non-negated glob.\n// e.g. `x.y.*[*].*`  $1 = `x.y`, $2 = `.*[*].*`\nconst NON_NEG_WILDCARD_TRAIL = /^(?!!)(.+?)(\\.\\*|\\[\\*\\])+$/;\nconst NEGATE_ALL = /^!(\\*|\\[\\*\\])$/;\n\nconst _reFlags = /\\w*$/;\n\nconst utils = {\n\n    re: {\n        VAR,\n        ARRAY_NOTE,\n        ARRAY_GLOB_NOTE,\n        OBJECT_BRACKETS,\n        WILDCARD,\n        WILDCARDS,\n        NON_NEG_WILDCARD_TRAIL,\n        NEGATE_ALL\n    },\n\n    type(o) {\n        return objProto.toString.call(o).match(/\\s(\\w+)/i)[1].toLowerCase();\n    },\n\n    isCollection(o) {\n        const t = utils.type(o);\n        return t === 'object' || t === 'array';\n    },\n\n    isset(o) {\n        return o !== undefined && o !== null;\n    },\n\n    ensureArray(o) {\n        if (utils.type(o) === 'array') return o;\n        return o === null || o === undefined ? [] : [o];\n    },\n\n    hasOwn(collection, keyOrIndex) {\n        if (!collection) return false;\n        const isArr = utils.type(collection) === 'array';\n        if (!isArr && typeof keyOrIndex === 'string') {\n            return keyOrIndex && objProto.hasOwnProperty.call(collection, keyOrIndex);\n        }\n        if (typeof keyOrIndex === 'number') {\n            return keyOrIndex >= 0 && keyOrIndex < collection.length;\n        }\n        return false;\n    },\n\n    deepCopy(collection) {\n        const t = utils.type(collection);\n        switch (t) {\n            case 'date':\n                return new Date(collection.valueOf());\n            case 'regexp': {\n                const flags = _reFlags.exec(collection).toString();\n                const copy = new collection.constructor(collection.source, flags);\n                copy.lastIndex = collection.lastIndex;\n                return copy;\n            }\n            case 'symbol':\n                return Object(symValueOf.call(collection));\n            case 'array':\n                return collection.map(utils.deepCopy);\n            case 'object': {\n                const copy = {};\n                // Plain objects are not iterable.\n                // `for (const k of collection) {}` will not work here.\n                for (const [k, value] of Object.entries(collection)) {\n                    const v = utils.deepCopy(value);\n                    if (k === '__proto__') {\n                        Object.defineProperty(copy, k, {\n                            configurable: true,\n                            enumerable: true,\n                            value: v,\n                            writable: true\n                        });\n                    } else {\n                        copy[k] = v;\n                    }\n                }\n                return copy;\n            }\n            // case 'string':\n            // case 'number':\n            // case 'boolean':\n            // case 'null':\n            // case 'undefined':\n            default: // other\n                return collection;\n        }\n    },\n\n    // iterates over elements of an array, executing the callback for each\n    // element.\n    each(array, callback, thisArg) {\n        const len = array.length;\n        let index = -1;\n        while (++index < len) {\n            if (callback.apply(thisArg, [array[index], index, array]) === false) break;\n        }\n    },\n\n    eachRight(array, callback, thisArg) {\n        let index = array.length;\n        while (index--) {\n            if (callback.apply(thisArg, [array[index], index, array]) === false) break;\n        }\n    },\n\n    eachProp(object, callback, thisArg) {\n        const keys = Object.keys(object);\n        let index = -1;\n        while (++index < keys.length) {\n            const key = keys[index];\n            if (callback.apply(thisArg, [object[key], key, object]) === false) break;\n        }\n    },\n\n    eachItem(collection, callback, thisArg) {\n        if (utils.type(collection) === 'array') {\n            return utils.each(collection, callback, thisArg);\n        }\n        return utils.eachProp(collection, callback, thisArg);\n    },\n\n    pregQuote(str) {\n        const re = /[.\\\\+*?[^\\]$(){}=!<>|:-]/g;\n        return String(str).replace(re, '\\\\$&');\n    },\n\n    stringOrArrayOf(o, value) {\n        return typeof value === 'string'\n            && (o === value\n                || (utils.type(o) === 'array' && o.length === 1 && o[0] === value)\n            );\n    },\n\n    hasSingleItemOf(arr, itemValue) {\n        return arr.length === 1\n            && (arguments.length === 2 ? arr[0] === itemValue : true);\n    },\n\n    // remove trailing/redundant wildcards if not negated\n    normalizeGlobStr(glob) {\n        return glob.trim().replace(NON_NEG_WILDCARD_TRAIL, '$1');\n    },\n\n    normalizeNote(note) {\n        if (VAR.test(note)) return note;\n        // check array index notation e.g. `[1]`\n        let m = note.match(ARRAY_NOTE);\n        if (m) return parseInt(m[1], 10);\n        // check object bracket notation e.g. `[\"a-b\"]`\n        m = note.match(OBJECT_BRACKETS);\n        if (m) return m[1] || m[2] || m[3];\n        throw new NotationError(`Invalid note: \"${note}\"`);\n    },\n\n    joinNotes(notes) {\n        const lastIndex = notes.length - 1;\n        return notes.map((current, i) => {\n            if (!current) return '';\n            const next = lastIndex >= i + 1 ? notes[i + 1] : null;\n            const dot = next\n                ? next[0] === '[' ? '' : '.'\n                : '';\n            return current + dot;\n        }).join('');\n    },\n\n    getNewNotation(newNotation, notation) {\n        const errMsg = `Invalid new notation: '${newNotation}'`;\n        // note validations (for newNotation and notation) are already made by\n        // other methods in the flow.\n        let newN;\n        if (typeof newNotation === 'string') {\n            newN = newNotation.trim();\n            if (!newN) throw new NotationError(errMsg);\n            return newN;\n        }\n        if (notation && !utils.isset(newNotation)) return notation;\n        throw new NotationError(errMsg);\n    }\n\n};\n\nexport { utils };\n"],"sourceRoot":""}