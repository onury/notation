{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 695326cdc884457c30e5","webpack:///./src/utils.js","webpack:///./src/core/notation.error.js","webpack:///./src/index.js","webpack:///./src/core/notation.js","webpack:///./src/core/notation.glob.js"],"names":["toString","Object","prototype","utils","isObject","o","call","isArray","ensureArray","undefined","hasOwn","prop","hasOwnProperty","deepCopy","object","k","copy","each","array","callback","thisArg","length","index","eachRight","pregQuote","str","delimiter","String","replace","RegExp","stringOrArrayOf","value","hasSingleItemOf","arr","itemValue","arguments","isArrIndex","note","test","splitNotation","notation","notes","chars","split","start","bracketCount","i","slice","join","push","concatNotes","reduce","acc","getIndexNumber","removeEmptyArraySpots","obj","keys","key","filter","e","map","NotationError","message","name","constructor","defineProperty","enumerable","writable","Error","captureStackTrace","stack","module","exports","Notation","ERR","SOURCE","DEST","NOTATION","NOTA_OBJ","_source","list","keyName","N","nKey","subKey","p","_subKey","entries","isValid","level","eachNote","levelNotation","create","merge","expand","result","has","lastNote","upToLast","parent","last","inspect","splice","defaultValue","overwrite","notationsObject","set","notations","inspectRemove","globNotations","original","globs","NotationGlob","normalize","concat","filtered","shift","g","endStar","normalized","endArrStar","globNotation","absGlob","indexOf","isNegated","remove","copyFrom","originalNotation","destination","newNotation","moveTo","rename","copyTo","extract","extrude","countNotes","pop","levelNotes","Glob","glob","ng","_","regexp","toRegExp","levels","bang","a","b","levelsA","levelsB","wild","mA","match","mB","wildA","wildB","negA","negB","nonNegA","nonNegB","globsArray","sort","compare","item","trim","globA","indexA","insA","duplicate","hasExactNegative","negCoversNeg","noPosCoversNeg","posCoversPos","noNegCoversPos","globB","indexB","insB","reB","redundant","globsA","globsB","arrA","arrB","reA","keepNegated","aIndex","bIndex"],"mappings":"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","file":"notation.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Notation\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Notation\"] = factory();\n\telse\n\t\troot[\"Notation\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"lib/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 695326cdc884457c30e5","\nlet toString = Object.prototype.toString;\n\nconst utils = {\n\n    isObject(o) {\n        return toString.call(o) === '[object Object]';\n    },\n\n    isArray(o) {\n        return toString.call(o) === '[object Array]';\n    },\n\n    ensureArray(o) {\n        if (utils.isArray(o)) return o;\n        return o === null || o === undefined ? [] : [o];\n    },\n\n    hasOwn(o, prop) {\n        return o && typeof o.hasOwnProperty === 'function' && o.hasOwnProperty(prop);\n    },\n\n    deepCopy(object) {\n        if (!utils.isObject(object)) return object;\n        let k, o,\n            copy = {};\n        for (k in object) {\n            if (utils.hasOwn(object, k)) {\n                o = object[k];\n                copy[k] = utils.isObject(o) ? utils.deepCopy(o) : o;\n            }\n        }\n        return copy;\n    },\n\n    // iterates over elements of an array, executing the callback for each\n    // element.\n    each(array, callback, thisArg) {\n        let length = array.length,\n            index = -1;\n        while (++index < length) {\n            if (callback.call(thisArg, array[index], index, array) === false) break;\n        }\n    },\n\n    eachRight(array, callback) {\n        let index = array.length;\n        while (index--) {\n            if (callback(array[index], index, array) === false) break;\n        }\n    },\n\n    // Borrowed from http://phpjs.org/functions/preg_quote\n    pregQuote(str, delimiter) {\n        return String(str)\n            .replace(new RegExp('[.\\\\\\\\+*?\\\\[\\\\^\\\\]$(){}=!<>|:\\\\' + (delimiter || '') + '-]', 'g'), '\\\\$&');\n    },\n\n    stringOrArrayOf(o, value) {\n        return (typeof o === 'string' && o === value)\n            || (utils.isArray(o) && o.length === 1 && o[0] === value);\n    },\n\n    hasSingleItemOf(arr, itemValue) {\n        return arr.length === 1\n            && (arguments.length === 2 ? arr[0] === itemValue : true);\n    },\n\n    isArrIndex(note) {\n        return /^\\[\\d+\\]$/.test(note);\n    },\n\n    splitNotation(notation) {\n        const notes = [];\n        const chars = notation.split('');\n        let start = 0;\n        let bracketCount = 0;\n        for (let i = 0; i < chars.length; i++) {\n          let note;\n          switch (true) {\n            case chars[i] === '.':\n              note = chars.slice(start, i).join('');\n              start = i + 1;\n              break;\n            case chars[i] === '[':\n              if (!bracketCount && start !== i) {\n                note = chars.slice(start, i).join('');\n                start = i;\n              }\n              bracketCount += 1;\n              break;\n            case chars[i] === ']':\n              bracketCount -= 1;\n              if (!bracketCount) {\n                note = chars.slice(start, i + 1).join('');\n                start = i + 1;\n              }\n              break;\n            case i === chars.length - 1:\n              note = chars.slice(start, i + 1).join('');\n              break;\n          }\n          if (typeof note === 'string' && note.length)\n            notes.push(note);\n        }\n        return notes;\n    },\n\n    concatNotes(notes) {\n        return notes.reduce((acc, note) => acc + (this.isArrIndex(note) ? note : `.${note}`))\n    },\n\n    getIndexNumber(notation) {\n        return +notation.replace(/[\\[\\]]/g, '');\n    },\n\n    removeEmptyArraySpots(obj) {\n        if (this.isObject(obj)) {\n            for (const key of Object.keys(obj)) {\n                obj[key] = this.removeEmptyArraySpots(obj[key]);\n            }\n            return obj;\n        } else if (this.isArray(obj)) {\n            return obj\n                .filter((e) => e !== undefined)\n                .map((e) => this.removeEmptyArraySpots(e));\n        } else {\n            return obj;\n        }\n    },\n};\n\nexport default utils;\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils.js","\n// TODO: instanceof return false.\n\n/**\n *  Error class specific to `Notation`.\n *  @name Notation.Error\n *  @memberof! Notation\n *  @class\n *\n */\nclass NotationError extends Error {\n\n    /**\n     *  Initializes a new `Notation.Error` instance.\n     *  @constructs Notation.Error\n     *  @param {String} message - The error message.\n     */\n    constructor(message = '') {\n        super(message);\n        this.name = this.constructor.name;\n\n        Object.defineProperty(this, 'name', {\n            enumerable: false,\n            writable: false,\n            value: 'NotationError'\n        });\n\n        Object.defineProperty(this, 'message', {\n            enumerable: false,\n            writable: true,\n            value: message\n        });\n\n        if (Error.hasOwnProperty('captureStackTrace')) { // V8\n            Error.captureStackTrace(this, this.constructor);\n        } else {\n            Object.defineProperty(this, 'stack', {\n                enumerable: false,\n                writable: false,\n                value: (new Error(message)).stack\n            });\n        }\n    }\n}\n\nexport default NotationError;\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/notation.error.js","import Notation from './core/notation';\n// export default Notation;\n// http://stackoverflow.com/a/33683495/112731\nmodule.exports = Notation;\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","import utils from '../utils';\nimport NotationGlob from './notation.glob';\nimport NotationError from './notation.error';\n\nconst ERR = {\n    SOURCE: 'Invalid source object.',\n    DEST: 'Invalid destination object.',\n    NOTATION: 'Invalid notation: ',\n    NOTA_OBJ: 'Invalid notations object: '\n};\n\n/**\n *  Notation.js for Node and Browser.\n *\n *  Like in most programming languages, JavaScript makes use of dot-notation to\n *  access the value of a member of an object (or class). `Notation` class\n *  provides various methods for modifying / processing the contents of the\n *  given object; by parsing object notation strings or globs.\n *\n *  Note that this class will only deal with enumerable properties of the source\n *  object; so it should be used to manipulate data objects. It will not deal\n *  with preserving the prototype-chain of the given object.\n *\n *  @author   Onur Yıldırım <onur@cutepilot.com>\n *  @license  MIT\n */\nclass Notation {\n\n    /**\n     *  Initializes a new instance of `Notation`.\n     *\n     *  @param {Object} [object={}] - The source object to be notated.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  const notation = new Notation(obj);\n     *  notation.get('car.model'); // \"Charger\"\n     */\n    constructor(object = {}) {\n        // if defined, it should be an object.\n        if (!utils.isObject(object)) {\n            throw new NotationError(ERR.SOURCE);\n        }\n        this._source = object;\n    }\n\n    // --------------------------------\n    // Notation Instance Properties\n    // --------------------------------\n\n    /**\n     *  Gets the value of the source object.\n     *  @type {Object}\n     *\n     *  @example\n     *  const person = { name: \"Onur\" };\n     *  const me = Notation.create(person)\n     *      .set(\"age\", 36)\n     *      .set(\"car.brand\", \"Ford\")\n     *      .set(\"car.model\", \"Mustang\")\n     *      .value;\n     *  console.log(me); // { name: \"Onur\", age: 36, car: { brand: \"Ford\", model: \"Mustang\" } }\n     *  console.log(person === me); // true\n     */\n    get value () {\n        return this._source;\n    }\n\n    // --------------------------------\n    // Notation Instance Methods\n    // --------------------------------\n\n    /**\n     *  Recursively iterates through each key of the source object and invokes\n     *  the given callback function with parameters, on each non-object value.\n     *  @alias Notation#eachKey\n     *\n     *  @param {Function} callback - The callback function to be invoked on\n     *  each on each non-object value. To break out of the loop, return `false`\n     *  from within the callback.\n     *  Callback signature: `callback(notation, key, value, object) { ... }`\n     *\n     *  @returns {void}\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  Notation.create(obj).each(function (notation, key, value, object) {\n     *      console.log(notation, value);\n     *  });\n     *  // \"car.brand\"  \"Dodge\"\n     *  // \"car.model\"  \"Charger\"\n     *  // \"car.year\"  1970\n     */\n    each (callback) {\n        const o = this._source;\n        const keys = Object.keys(o);\n        const isArray = utils.isArray(o);\n\n        utils.each(keys, (key, index, list) => {\n            // this is preserved in arrow functions\n            const prop = o[key];\n            const keyName = isArray ? `[${key}]` : key;\n            let N;\n            if (utils.isObject(prop)) {\n                N = new Notation(prop);\n                N.each((notation, nKey, value, prop) => {\n                    let subKey = keyName + '.' + notation;\n                    callback.call(N, subKey, nKey, value, o);\n                });\n            } else if (utils.isArray(prop)) {\n                for (const [i, p] of prop.entries()) {\n                    let subKey = `${keyName}[${i}]`;\n                    if (!(utils.isObject(p) || utils.isArray(p))) {\n                        callback.call(this, subKey, subKey, p, o);\n                    } else {\n                        N = new Notation(p);\n                        N.each((notation, nKey, value, prop) => {\n                            let _subKey = subKey + '.' + notation;\n                            callback.call(N, _subKey, nKey, value, o);\n                        });\n                    }\n                }\n            } else {\n                callback.call(this, keyName, keyName, prop, o);\n            }\n        });\n    }\n    /**\n     *  Alias for `#each`\n     *  @private\n     */\n    eachKey (callback) {\n        return this.each(callback);\n    }\n\n    /**\n     *  Iterates through each note of the given notation string by evaluating\n     *  it on the source object.\n     *\n     *  @param {String} notation - The notation string to be iterated through.\n     *  @param {Function} callback - The callback function to be invoked on\n     *  each iteration. To break out of the loop, return `false` from within\n     *  the callback.\n     *  Callback signature: `callback(levelValue, note, index, list) { ... }`\n     *\n     *  @returns {void}\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  Notation.create(obj)\n     *      .eachValue(\"car.brand\", function (levelValue, note, index, list) {\n     *          console.log(note, levelValue); // \"car.brand\" \"Dodge\"\n     *      });\n     */\n    eachValue (notation, callback) {\n        if (!Notation.isValid(notation)) {\n            throw new NotationError(ERR.NOTATION + '`' + notation + '`');\n        }\n        var level = this._source;\n        Notation.eachNote(notation, (levelNotation, note, index, list) => {\n            level = utils.hasOwn(level, note) ? level[note] : undefined;\n            if (callback(level, levelNotation, note, index, list) === false) return false;\n\n        });\n    }\n\n    /**\n     *  Gets the list of notations from the source object (keys).\n     *\n     *  @returns {Array} - An array of notation strings.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  const notations = Notation.create(obj).getNotations();\n     *  console.log(notations); // [ \"car.brand\", \"car.model\", \"car.year\" ]\n     */\n    getNotations () {\n        let list = [];\n        this.each((notation, key, value, obj) => {\n            list.push(notation);\n        });\n        return list;\n    }\n\n    /**\n     *  Flattens the source object to a single-level object with notated keys.\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  const flat = Notation.create(obj).flatten().value;\n     *  console.log(flat);\n     *  // { \"car.brand\": \"Dodge\", \"car.model\": \"Charger\", \"car.year\": 1970 }\n     */\n    flatten () {\n        let o = {};\n        this.each((notation, key, value, obj) => {\n            o[notation] = value;\n        });\n        // return o;\n        this._source = o;\n        return this;\n    }\n\n    /**\n     *  Aggregates notated keys of a (single-level) object, and nests them under\n     *  their corresponding properties. This is the opposite of `Notation#flatten`\n     *  method. This might be useful when expanding a flat object fetched from\n     *  a database.\n     *  @alias Notation#aggregate\n     *  @chainable\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  const obj = { \"car.brand\": \"Dodge\", \"car.model\": \"Charger\", \"car.year\": 1970 }\n     *  const expanded = Notation.create(obj).expand().value;\n     *  console.log(expanded); // { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     */\n    expand () {\n        this._source = Notation.create({}).merge(this._source).value;\n        return this;\n    }\n    /**\n     *  Alias for `#expand`\n     *  @private\n     */\n    aggregate () {\n        return this.expand();\n    }\n\n    /**\n     *  Inspects the given notation on the source object by checking\n     *  if the source object actually has the notated property;\n     *  and getting its value if exists.\n     *\n     *  @param {String} notation - The notation string to be inspected.\n     *\n     *  @returns {InspectResult} - The result object.\n     *\n     *  @example\n     *  Notation.create({ car: { year: 1970 } }).inspect(\"car.year\");\n     *  // { has: true, value: 1970 }\n     *  Notation.create({ car: { year: 1970 } }).inspect(\"car.color\");\n     *  // { has: false, value: undefined }\n     *  Notation.create({ car: { color: undefined } }).inspect(\"car.color\");\n     *  // { has: true, value: undefined }\n     */\n    inspect (notation) {\n        if (!Notation.isValid(notation)) {\n            throw new NotationError(ERR.NOTATION + '`' + notation + '`');\n        }\n        let level = this._source,\n            result = { has: false, value: undefined };\n        Notation.eachNote(notation, (levelNotation, note, index, list, isArray) => {\n            note = utils.isArrIndex(note)\n                ? utils.getIndexNumber(note)\n                : note;\n\n            if (utils.hasOwn(level, note)) {\n                level = level[note];\n                result = { has: true, value: level };\n            } else {\n                result = { has: false, value: undefined };\n                return false; // break out\n            }\n        });\n        return result;\n    }\n    /**\n     *  Notation inspection result object.\n     *  @typedef Notation~InspectResult\n     *  @type Object\n     *  @property {Boolean} has - Indicates whether the source object has the given\n     *  notation as a (leveled) enumerable property. If the property exists but has\n     *  a value of `undefined`, this will still return `true`.\n     *  @property {*} value - The value of the notated property. If the source object\n     *  does not have the notation, the value will be `undefined`.\n     */\n\n    /**\n     *  Inspects and removes the given notation from the source object\n     *  by checking if the source object actually has the notated property;\n     *  and getting its value if exists, before removing the property.\n     *\n     *  @param {String} notation - The notation string to be inspected.\n     *\n     *  @returns {InspectResult} - The result object.\n     *\n     *  @example\n     *  const obj = { name: \"John\", car: { year: 1970 } };\n     *  Notation.create(obj).inspectRemove(\"car.year\"); // { has: true, value: 1970 }\n     *  // obj » { name: \"John\", car: {} }\n     *  Notation.create(obj).inspectRemove(\"car.year\", true); // { has: true, value: 1970 }\n     *  // obj » { name: \"John\" }\n     *  Notation.create({ car: { year: 1970 } }).inspectRemove(\"car.color\");\n     *  // { has: false, value: undefined }\n     *  Notation.create({ car: { color: undefined } }).inspectRemove(\"car.color\");\n     *  // { has: true, value: undefined }\n     */\n    inspectRemove (notation) {\n        if (!Notation.isValid(notation)) {\n            throw new NotationError(ERR.NOTATION + '`' + notation + '`');\n        }\n        let o, lastNote;\n        const notes = utils.splitNotation(notation);\n        if (notes.length === 1) {\n            lastNote = notation;\n            o = this._source;\n        } else {\n            let upToLast = Notation.parent(notation);\n            lastNote = Notation.last(notation);\n            o = this.inspect(upToLast).value;\n        }\n        let result;\n        lastNote = utils.isArrIndex(lastNote) ? utils.getIndexNumber(lastNote) : lastNote;\n\n        if (utils.hasOwn(o, lastNote)) {\n            if (utils.isArray(o)) {\n                result = { has: true, value: o.splice(lastNote, 1)[0] };\n            } else {\n                result = { has: true, value: o[lastNote] };\n                delete o[lastNote];\n            }\n        } else {\n            result = { has: false, value: undefined };\n        }\n\n        return result;\n    }\n\n    /**\n     *  Checks whether the source object has the given notation\n     *  as a (leveled) enumerable property. If the property exists\n     *  but has a value of `undefined`, this will still return `true`.\n     *\n     *  @param {String} notation - The notation string to be checked.\n     *\n     *  @returns {Boolean}\n     *\n     *  @example\n     *  Notation.create({ car: { year: 1970 } }).has(\"car.year\"); // true\n     *  Notation.create({ car: { year: undefined } }).has(\"car.year\"); // true\n     *  Notation.create({}).has(\"car.color\"); // false\n     */\n    has (notation) {\n        return this.inspect(notation).has;\n    }\n\n    /**\n     *  Checks whether the source object has the given notation\n     *  as a (leveled) defined enumerable property. If the property\n     *  exists but has a value of `undefined`, this will return `false`.\n     *\n     *  @param {String} notation - The notation string to be checked.\n     *\n     *  @returns {Boolean}\n     *\n     *  @example\n     *  Notation.create({ car: { year: 1970 } }).hasDefined(\"car.year\"); // true\n     *  Notation.create({ car: { year: undefined } }).hasDefined(\"car.year\"); // false\n     *  Notation.create({}).hasDefined(\"car.color\"); // false\n     */\n    hasDefined (notation) {\n        return this.inspect(notation).value !== undefined;\n    }\n\n    /**\n     *  Gets the value of the corresponding property at the given\n     *  notation.\n     *\n     *  @param {String} notation - The notation string to be processed.\n     *  @param {String} [defaultValue] - The default value to be returned if\n     *  the property is not found or enumerable.\n     *\n     *  @returns {*} - The value of the notated property.\n     *\n     *  @example\n     *  Notation.create({ car: { brand: \"Dodge\" } }).get(\"car.brand\"); // \"Dodge\"\n     *  Notation.create({ car: {} }).get(\"car.model\"); // undefined\n     *  Notation.create({ car: {} }).get(\"car.model\", \"Challenger\"); // \"Challenger\"\n     *  Notation.create({ car: { model: undefined } }).get(\"car.model\", \"Challenger\"); // undefined\n     */\n    get (notation, defaultValue) {\n        let result = this.inspect(notation);\n        return !result.has ? defaultValue : result.value;\n    }\n\n    /**\n     *  Sets the value of the corresponding property at the given\n     *  notation. If the property does not exist, it will be created\n     *  and nested at the calculated level. If it exists; its value\n     *  will be overwritten by default.\n     *  @chainable\n     *\n     *  @param {String} notation - The notation string to be processed.\n     *  @param {*} value - The value to be set for the notated property.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property\n     *  if exists.\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", year: 1970 } };\n     *  Notation.create(obj)\n     *      .set(\"car.brand\", \"Ford\")\n     *      .set(\"car.model\", \"Mustang\")\n     *      .set(\"car.year\", 1965, false)\n     *      .set(\"car.color\", \"red\")\n     *      .set(\"boat\", \"none\");\n     *  console.log(obj);\n     *  // { notebook: \"Mac\", car: { brand: \"Ford\", model: \"Mustang\", year: 1970, color: \"red\" }, boat: \"none\" };\n     */\n    set (notation, value, overwrite = true) {\n        if (!Notation.isValid(notation)) {\n            throw new NotationError(ERR.NOTATION + '`' + notation + '`');\n        }\n        let level = this._source,\n            last;\n        Notation.eachNote(notation, (levelNotation, note, index, list, isArray) => {\n            note = utils.isArrIndex(note) ? +note.replace(/[\\[\\]]/g, '') : note;\n            last = index === list.length - 1;\n\n            // check if the property is at this level\n            if (utils.hasOwn(level, note)) {\n                // check if we're at the last level\n                if (last) {\n                    // if overwrite is set, assign the value.\n                    if (overwrite) level[note] = value;\n                } else {\n                    // if not, just re-reference the current level.\n                    level = level[note];\n                }\n            } else {\n                // we don't have this property at this level\n                // so; if this is the last level, we set the value\n                // if not, we set an empty object for the next level\n                level = level[note] = last ? value : isArray ? [] : {};\n            }\n        });\n        return this;\n    }\n\n    /**\n     *  Just like the `.set()` method but instead of a single notation\n     *  string, an object of notations and values can be passed.\n     *  Sets the value of each corresponding property at the given\n     *  notation. If a property does not exist, it will be created\n     *  and nested at the calculated level. If it exists; its value\n     *  will be overwritten by default.\n     *  @chainable\n     *\n     *  @param {Object} notationsObject - The notations object to be processed.\n     *  This can either be a regular object with non-dotted keys\n     *  (which will be merged to the first/root level of the source object);\n     *  or a flattened object with notated (dotted) keys.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite a property if\n     *  exists.\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", year: 1970 } };\n     *  Notation.create(obj).merge({\n     *      \"car.brand\": \"Ford\",\n     *      \"car.model\": \"Mustang\",\n     *      \"car.year\": 1965,\n     *      \"car.color\": \"red\",\n     *      \"boat\": \"none\"\n     *  });\n     *  console.log(obj);\n     *  // { car: { brand: \"Ford\", model: \"Mustang\", year: 1970, color: \"red\" }, boat: \"none\" };\n     */\n    merge (notationsObject, overwrite = true) {\n        if (!utils.isObject(notationsObject)) {\n            throw new NotationError(ERR.NOTA_OBJ + '`' + notationsObject + '`');\n        }\n        let value;\n        utils.each(Object.keys(notationsObject), (notation, index, obj) => {\n            // this is preserved in arrow functions\n            value = notationsObject[notation];\n            this.set(notation, value, overwrite);\n        });\n        return this;\n    }\n\n    /**\n     *  Removes the properties by the given list of notations from the source\n     *  object and returns a new object with the removed properties.\n     *  Opposite of `merge()` method.\n     *\n     *  @param {Array} notations - The notations array to be processed.\n     *\n     *  @returns {Object} - An object with the removed properties.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", year: 1970 }, notebook: \"Mac\" };\n     *  const separated = Notation.create(obj).separate([\"car.brand\", \"boat\" ]);\n     *  console.log(separated);\n     *  // { notebook: \"Mac\", car: { brand: \"Ford\" } };\n     *  console.log(obj);\n     *  // { car: { year: 1970 } };\n     */\n    separate (notations) {\n        if (!utils.isArray(notations)) {\n            throw new NotationError(ERR.NOTA_OBJ + '`' + notations + '`');\n        }\n        let o = new Notation({});\n        utils.each(notations, (notation, index, obj) => {\n            let result = this.inspectRemove(notation);\n            o.set(notation, result.value);\n        });\n        this._source = o._source;\n        return this;\n    }\n\n    /**\n     *  Deep clones the source object while filtering its properties\n     *  by the given glob notations. Includes all matched properties\n     *  and removes the rest.\n     *\n     *  @param {Array|String} globNotations - The glob notation(s) to\n     *  be processed. The difference between normal notations and\n     *  glob-notations is that you can use wildcard stars (*) and\n     *  negate the notation by prepending a bang (!). A negated\n     *  notation will be excluded. Order of the globs do not matter,\n     *  they will be logically sorted. Loose globs will be processed\n     *  first and verbose globs or normal notations will be processed\n     *  last. e.g. `[ \"car.model\", \"*\", \"!car.*\" ]` will be sorted as\n     *  `[ \"*\", \"!car.*\", \"car.model\" ]`.\n     *  Passing no parameters or passing an empty string (`\"\"` or `[\"\"]`)\n     *  will empty the source object.\n     *  @chainable\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  const obj = { notebook: \"Mac\", car: { brand: \"Ford\", model: \"Mustang\", year: 1970, color: \"red\" } };\n     *  const notation = Notation.create(obj);\n     *  notation.filter([ \"*\", \"!car.*\", \"car.model\" ]);\n     *  console.log(obj);       // { notebook: \"Mac\", car: { model: \"Mustang\" } }\n     *  notation.filter(\"*\");   // re-filtering the current contents\n     *  console.log(obj);       // { notebook: \"Mac\", car: { model: \"Mustang\" } }\n     *  notation.filter();      // or notation.filter(\"\");\n     *  console.log(obj);       // {}\n     */\n    filter (globNotations) {\n        let original = this.value;\n        let copy = utils.deepCopy(original);\n\n        // ensure array, normalize and sort the globs in logical order. we also\n        // concat the array first (to prevent mutating the original) bec. we'll\n        // change it's content via `.shift()`\n        let globs = NotationGlob.normalize(globNotations).concat();\n\n        // if globs only consist of \"*\"; set the \"copy\" as source and return.\n        if (utils.stringOrArrayOf(globs, '*')) {\n            this._source = copy;\n            return this;\n        }\n        // if globs is \"\" or [\"\"] set source to `{}` and return.\n        if (arguments.length === 0\n            || utils.stringOrArrayOf(globs, '')\n            || utils.stringOrArrayOf(globs, '!*')) {\n            this._source = {};\n            return this;\n        }\n\n        let filtered;\n        // if the first item of sorted globs is \"*\" we set the source to the\n        // (full) \"copy\" and remove the \"*\" from globs (not to re-process).\n        if (globs[0] === '*') {\n            filtered = new Notation(copy);\n            globs.shift();\n        } else {\n            // otherwise we set an empty object as the source so that we can\n            // add notations/properties to it.\n            filtered = new Notation({});\n        }\n\n        let g, endStar, normalized, endArrStar;\n        // iterate through globs\n        utils.each(globs, (globNotation, index, array) => {\n            // console.log('--->', globNotation);\n            g = new NotationGlob(globNotation);\n            // set flag that indicates whether the glob ends with `.*`\n            endStar = g.absGlob.slice(-2) === '.*';\n            // set flag that indicates whether the glob ends with `[*]`\n            endArrStar = g.absGlob.slice(-3) === '[*]';\n            // get the remaining part as the (extra) normalized glob\n            normalized = g.absGlob.replace(/(\\.\\*$)|(\\[\\*\\]$)/, '');\n            // normalized = endStar ? g.absGlob.replace(/(\\.\\*)+$/, '') : g.absGlob;\n            // check if normalized glob has no wildcard stars e.g. \"a.b\" or\n            // \"!a.b.c\" etc..\n\n            if (normalized.indexOf('*') < 0) {\n                if (g.isNegated) {\n                    // directly remove the notation if negated\n                    filtered.remove(normalized);\n                    // if original glob had `.*` at the end, it means remove\n                    // contents (not itself). so we'll set an empty object.\n                    // meaning `some.prop` (prop) is removed completely but\n                    // `some.prop.*` (prop) results in `{}`.\n                    if (endStar) filtered.set(normalized, {}, true);\n                    else if (endArrStar) filtered.set(normalized, [], true);\n                } else {\n                    // directly copy the same notation from the original\n                    filtered.copyFrom(original, normalized, null, true);\n                }\n                // move to the next\n                return true;\n            }\n            // if glob has wildcard star(s), we'll iterate through keys of the\n            // source object and see if (full) notation of each key matches\n            // the current glob.\n\n            // TODO: Optimize the loop below. Instead of checking each key's\n            // notation, get the non-star left part of the glob and iterate\n            // that property of the source object.\n            this.each((originalNotation, key, value, obj) => {\n                // console.log('>>', originalNotation);\n\n                // iterating each note of original notation. i.e.:\n                // note1.note2.note3 is iterated from left to right, as:\n                // 'note1', 'note1.note2', 'note1.note2.note3' — in order.\n                Notation.eachNote(originalNotation, (levelNotation, note, index, list) => {\n                    if (g.test(levelNotation)) {\n                        if (g.isNegated) {\n                            // console.log('removing', levelNotation, 'of', originalNotation);\n                            filtered.remove(levelNotation);\n                            // we break and return early if removed bec. deeper\n                            // level props are also removed with this parent.\n                            // e.g. when 'note1.note2' of 'note1.note2.note3' is\n                            // removed, we no more have 'note3'.\n                            return false;\n                        }\n                        filtered.set(levelNotation, value, true);\n                    }\n                });\n            });\n        });\n        // finally set the filtered's value as the source of our instance and\n        // return.\n        this._source = filtered.value;\n        return this;\n    }\n\n    /**\n     *  Removes the property from the source object, at the given notation.\n     *  @alias Notation#delete\n     *  @chainable\n     *\n     *  @param {String} notation - The notation to be inspected.\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  const obj = { notebook: \"Mac\", car: { model: \"Mustang\" } };\n     *  Notation.create(obj).remove(\"car.model\");\n     *  console.log(obj); // { notebook: \"Mac\", car: { } }\n     */\n    remove (notation) {\n        this.inspectRemove(notation);\n        return this;\n    }\n    /**\n     *  Alias of `Notation#remove`\n     *  @private\n     */\n    delete (notation) {\n        this.remove(notation);\n        return this;\n    }\n\n    /**\n     *  Clones the `Notation` instance to a new one.\n     *\n     *  @returns {Notation} - A new copy of the instance.\n     */\n    clone () {\n        let o = utils.deepCopy(this.value);\n        return new Notation(o);\n    }\n\n    /**\n     *  Copies the notated property from the source object and adds it to the\n     *  destination — only if the source object actually has that property.\n     *  This is different than a property with a value of `undefined`.\n     *  @chainable\n     *\n     *  @param {Object} destination - The destination object that the notated\n     *  properties will be copied to.\n     *  @param {String} notation - The notation to get the corresponding property\n     *  from the source object.\n     *  @param {String} [newNotation=null] - The notation to set the source property\n     *  on the destination object. In other words, the copied property will be\n     *  renamed to this value before set on the destination object. If not set,\n     *  `notation` argument will be used.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property on\n     *  the destination object if it exists.\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  const models = { dodge: \"Charger\" };\n     *  Notation.create(obj).copyTo(models, \"car.model\", \"ford\");\n     *  console.log(models);\n     *  // { dodge: \"Charger\", ford: \"Mustang\" }\n     *  // source object (obj) is not modified\n     */\n    copyTo (destination, notation, newNotation = null, overwrite = true) {\n        if (!(utils.isObject(destination) || utils.isArray(destination)))\n            throw new NotationError(ERR.DEST);\n\n        let result = this.inspect(notation);\n        if (result.has) {\n            new Notation(destination).set(newNotation || notation, result.value, overwrite);\n        }\n        return this;\n    }\n\n    /**\n     *  Copies the notated property from the destination object and adds it to the\n     *  source object — only if the destination object actually has that property.\n     *  This is different than a property with a value of `undefined`.\n     *  @chainable\n     *\n     *  @param {Object} destination - The destination object that the notated\n     *  properties will be copied from.\n     *  @param {String} notation - The notation to get the corresponding property\n     *  from the destination object.\n     *  @param {String} [newNotation=null] - The notation to set the destination\n     *  property on the source object. In other words, the copied property\n     *  will be renamed to this value before set on the source object.\n     *  If not set, `notation` argument will be used.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property\n     *  on the source object if it exists.\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  const models = { dodge: \"Charger\" };\n     *  Notation.create(obj).copyFrom(models, \"dodge\", \"car.model\", true);\n     *  console.log(obj);\n     *  // { car: { brand: \"Ford\", model: \"Charger\" } }\n     *  // models object is not modified\n     */\n    copyFrom (destination, notation, newNotation = null, overwrite = true) {\n        if (!utils.isObject(destination)) throw new NotationError(ERR.DEST);\n        let result = new Notation(destination).inspect(notation);\n        if (result.has) {\n            this.set(newNotation || notation, result.value, overwrite);\n        }\n        return this;\n    }\n\n    /**\n     *  Removes the notated property from the source object and adds it to the\n     *  destination — only if the source object actually has that property.\n     *  This is different than a property with a value of `undefined`.\n     *  @chainable\n     *\n     *  @param {Object} destination - The destination object that the notated\n     *  properties will be moved to.\n     *  @param {String} notation - The notation to get the corresponding\n     *  property from the source object.\n     *  @param {String} [newNotation=null] - The notation to set the source property\n     *  on the destination object. In other words, the moved property will be\n     *  renamed to this value before set on the destination object. If not set,\n     *  `notation` argument will be used.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property on\n     *  the destination object if it exists.\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  const models = { dodge: \"Charger\" };\n     *  Notation.create(obj).moveTo(models, \"car.model\", \"ford\");\n     *  console.log(obj);\n     *  // { car: { brand: \"Ford\" } }\n     *  console.log(models);\n     *  // { dodge: \"Charger\", ford: \"Mustang\" }\n     */\n    moveTo (destination, notation, newNotation = null, overwrite = true) {\n        if (!(utils.isObject(destination) || utils.isArray(destination)))\n            throw new NotationError(ERR.DEST);\n        let result = this.inspectRemove(notation);\n\n        if (result.has) {\n            new Notation(destination).set(newNotation || notation, result.value, overwrite);\n        }\n        return this;\n    }\n\n    /**\n     *  Removes the notated property from the destination object and adds it to the\n     *  source object — only if the destination object actually has that property.\n     *  This is different than a property with a value of `undefined`.\n     *  @chainable\n     *\n     *  @param {Object} destination - The destination object that the notated\n     *  properties will be moved from.\n     *  @param {String} notation - The notation to get the corresponding property\n     *  from the destination object.\n     *  @param {String} [newNotation=null] - The notation to set the destination\n     *  property on the source object. In other words, the moved property\n     *  will be renamed to this value before set on the source object.\n     *  If not set, `notation` argument will be used.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property on\n     *  the source object if it exists.\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  const models = { dodge: \"Charger\" };\n     *  Notation.create(obj).moveFrom(models, \"dodge\", \"car.model\", true);\n     *  console.log(obj);\n     *  // { car: { brand: \"Ford\", model: \"Charger\" } }\n     *  console.log(models);\n     *  // {}\n     */\n    moveFrom (destination, notation, newNotation = null, overwrite = true) {\n        if (!utils.isObject(destination)) throw new NotationError(ERR.DEST);\n        let result = new Notation(destination).inspectRemove(notation);\n        if (result.has) {\n            this.set(newNotation || notation, result.value, overwrite);\n        }\n        return this;\n    }\n\n    /**\n     *  Renames the notated property of the source object by the new notation.\n     *  @alias Notation#renote\n     *  @chainable\n     *\n     *  @param {String} notation - The notation to get the corresponding\n     *  property (value) from the source object.\n     *  @param {String} newNotation - The new notation for the targeted\n     *  property value. If not set, the source object will not be modified.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property at\n     *  the new notation, if it exists.\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  Notation.create(obj)\n     *      .rename(\"car.brand\", \"carBrand\")\n     *      .rename(\"car.model\", \"carModel\");\n     *  console.log(obj);\n     *  // { carBrand: \"Ford\", carModel: \"Mustang\" }\n     */\n    rename (notation, newNotation, overwrite) {\n        if (!newNotation) return this;\n        return this.moveTo(this._source, notation, newNotation, overwrite);\n    }\n    /**\n     *  Alias for `#rename`\n     *  @private\n     */\n    renote (notation, newNotation, overwrite) {\n        return this.rename(notation, newNotation, overwrite);\n    }\n\n    /**\n     *  Extracts the property at the given notation to a new object by copying\n     *  it from the source object. This is equivalent to `.copyTo({}, notation, newNotation)`.\n     *  @alias Notation#copyToNew\n     *\n     *  @param {String} notation - The notation to get the corresponding\n     *  property (value) from the source object.\n     *  @param {String} newNotation - The new notation to be set on the new\n     *  object for the targeted property value. If not set, `notation` argument\n     *  will be used.\n     *\n     *  @returns {Object} - Returns a new object with the notated property.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  const extracted = Notation.create(obj).extract(\"car.brand\", \"carBrand\");\n     *  console.log(extracted);\n     *  // { carBrand: \"Ford\" }\n     *  // obj is not modified\n     */\n    extract (notation, newNotation) {\n        let o = {};\n        this.copyTo(o, notation, newNotation);\n        // remove all empty array fields\n        o = utils.removeEmptyArraySpots(o);\n        return o;\n    }\n    /**\n     *  Alias for `#extract`\n     *  @private\n     */\n    copyToNew (notation, newNotation) {\n        return this.extract(notation, newNotation);\n    }\n\n    /**\n     *  Extrudes the property at the given notation to a new object by moving\n     *  it from the source object. This is equivalent to `.moveTo({}, notation, newNotation)`.\n     *  @alias Notation#moveToNew\n     *\n     *  @param {String} notation - The notation to get the corresponding\n     *  property (value) from the source object.\n     *  @param {String} newNotation - The new notation to be set on the new\n     *  object for the targeted property value. If not set, `notation` argument\n     *  will be used.\n     *\n     *  @returns {Object} - Returns a new object with the notated property.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  const extruded = Notation.create(obj).extrude(\"car.brand\", \"carBrand\");\n     *  console.log(obj);\n     *  // { car: { model: \"Mustang\" } }\n     *  console.log(extruded);\n     *  // { carBrand: \"Ford\" }\n     */\n    extrude (notation, newNotation) {\n        let o = {};\n        this.moveTo(o, notation, newNotation);\n        o = utils.removeEmptyArraySpots(o);\n        return o;\n    }\n    /**\n     *  Alias for `#extrude`\n     *  @private\n     */\n    moveToNew (notation, newNotation) {\n        return this.extrude(notation, newNotation);\n    }\n\n    // --------------------------------\n    // Notation Static Methods\n    // --------------------------------\n\n    /**\n     *  Basically constructs a new `Notation` instance with the given object.\n     *  @chainable\n     *\n     *  @param {Object} [object={}] - The object to be notated.\n     *\n     *  @returns {Notation} - The created instance.\n     *\n     *  @example\n     *  const notation = Notation.create(obj);\n     *  // equivalent to:\n     *  const notation = new Notation(obj);\n     */\n    static create (object = {}) {\n        return new Notation(object);\n    }\n\n    /**\n     *  Checks whether the given notation string is valid. Note that the star\n     *  (`*`) (which is a valid character, even if irregular) is NOT treated as\n     *  wildcard here. This checks for normal dot-notation, not a glob-notation.\n     *  For glob notation validation, use `Notation.Glob.isValid()` method. Same\n     *  goes for the negation character/prefix (`!`).\n     *\n     *  Note that, even though `obj['some.name']` is possible in JS, dot (`.`) is\n     *  always treated as a level (property) separator in Notation strings.\n     *\n     *  @param {String} notation - The notation string to be checked.\n     *\n     *  @returns {Boolean}\n     *\n     *  @example\n     *  Notation.isValid('prop1.prop2.prop3'); // true\n     *  Notation.isValid('prop1'); // true\n     *  Notation.isValid('prop.*'); // true (but star is not treated as wildcard)\n     *  Notation.isValid('@1'); // true (bec. obj['@1'] is possible in JS.)\n     *  Notation.isValid(null); // false\n     */\n\n    static isValid (notation) {\n        return (typeof notation === 'string') &&\n            // https://regex101.com/r/fSUY00/2\n            (/^[^\\s.!\\[\\]]+((\\.[^\\s.!\\[\\]]+)|(\\[(\\d+|(['\"`]){1}\\*?\\5{1})\\]))*$/).test(notation);\n    }\n\n    /**\n     *  Counts the number of notes/levels in the given notation.\n     *  @alias Notation.countLevels\n     *\n     *  @param {*} notation - The notation string to be processed.\n     *\n     *  @returns {Number}\n     */\n    static countNotes (notation) {\n        if (!Notation.isValid(notation)) {\n            throw new NotationError(ERR.NOTATION + '`' + notation + '`');\n        }\n        return utils.splitNotation(notation).length;\n    }\n    /**\n     *  Alias of `Notation.countNotes`.\n     *  @private\n     */\n    static countLevels (notation) {\n        return Notation.countNotes(notation);\n    }\n\n    /**\n     *  Gets the first (root) note of the notation string.\n     *\n     *  @param {String} notation - The notation string to be processed.\n     *\n     *  @returns {String}\n     *\n     *  @example\n     *  Notation.first('first.prop2.last'); // \"first\"\n     */\n    static first (notation) {\n        if (!Notation.isValid(notation)) {\n            throw new NotationError(ERR.NOTATION + '`' + notation + '`');\n        }\n        // return notation.replace(/.*\\.([^\\.]*$)/, '$1');\n        return notation.split('.')[0];\n    }\n\n    /**\n     *  Gets the last note of the notation string.\n     *\n     *  @param {String} notation - The notation string to be processed.\n     *\n     *  @returns {String}\n     *\n     *  @example\n     *  Notation.last('first.prop2.last'); // \"last\"\n     */\n    static last (notation) {\n        if (!Notation.isValid(notation)) {\n            throw new NotationError(ERR.NOTATION + '`' + notation + '`');\n        }\n        // return notation.replace(/.*\\.([^\\.]*$)/, '$1');\n        return utils.splitNotation(notation).pop();\n    }\n\n    /**\n     *  Gets the parent notation (up to but excluding the last note)\n     *  from the notation string.\n     *\n     *  @param {String} notation - The notation string to be processed.\n     *\n     *  @returns {String}\n     *\n     *  @example\n     *  Notation.parent('first.prop2.last'); // \"first.prop2\"\n     *  Notation.parent('single'); // null\n     */\n    static parent (notation) {\n        if (!Notation.isValid(notation)) {\n            throw new NotationError(ERR.NOTATION + '`' + notation + '`');\n        }\n        const notes = utils.splitNotation(notation);\n        return notes.length > 1\n            ? utils.concatNotes(notes.slice(0, -1))\n            : null;\n    }\n\n    /**\n     *  Iterates through each note/level of the given notation string.\n     *  @alias Notation.eachLevel\n     *\n     *  @param {String} notation - The notation string to be iterated through.\n     *  @param {Function} callback - The callback function to be invoked on\n     *  each iteration. To break out of the loop, return `false` from within the\n     *  callback.\n     *  Callback signature: `callback(levelNotation, note, index, list) { ... }`\n     *\n     *  @returns {void}\n     *\n     *  @example\n     *  const notation = 'first.prop2.last';\n     *  Notation.eachNote(notation, function (levelNotation, note, index, list) {\n     *      console.log(index, note, levelNotation);\n     *  });\n     *  // 0  \"first\"             \"first\"\n     *  // 1  \"first.prop2\"       \"prop2\"\n     *  // 2  \"first.prop2.last\"  \"last\"\n     */\n    static eachNote (notation, callback) {\n        if (!Notation.isValid(notation)) {\n            throw new NotationError(ERR.NOTATION + '`' + notation + '`');\n        }\n        let notes = utils.splitNotation(notation),\n            levelNotes = [],\n            levelNotation;\n        utils.each(notes, (note, index, list) => {\n            levelNotes.push(note);\n            levelNotation = utils.concatNotes(levelNotes);\n            const isArray = !!(notes[index + 1] && utils.isArrIndex(notes[index + 1]));\n            if (callback(levelNotation, note, index, notes, isArray) === false) return false;\n        }, Notation);\n    }\n    /**\n     *  Alias of `Notation.eachNote`.\n     *  @private\n     */\n    static eachLevel (notation, callback) {\n        Notation.eachNote(notation, callback);\n    }\n\n}\n\n/**\n *  Error class specific to `Notation`.\n *  @private\n *\n *  @class\n *  @see `{@link #Notation.Error}`\n */\nNotation.Error = NotationError;\n\n/**\n *  Utility for validating, comparing and sorting dot-notation globs.\n *  This is internally used by `Notation` class.\n *  @private\n *\n *  @class\n *  @see `{@link #Notation.Glob}`\n */\nNotation.Glob = NotationGlob;\n\n// --------------------------------\n// EXPORT\n// --------------------------------\n\nexport default Notation;\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/notation.js","import utils from '../utils';\nimport NotationError from './notation.error';\n\n// http://www.linfo.org/wildcard.html\n// http://en.wikipedia.org/wiki/Glob_%28programming%29\n// http://en.wikipedia.org/wiki/Wildcard_character#Computing\n\n/**\n *  `Notation.Glob` is a utility for validating, comparing and sorting\n *  dot-notation globs.\n *\n *  You can use {@link http://www.linfo.org/wildcard.html|wildcard} stars `*`\n *  and negate the notation by prepending a bang `!`. A star will include all\n *  the properties at that level and a negated notation will be excluded.\n *  @name Notation.Glob\n *  @memberof! Notation\n *  @class\n *\n *  @example\n *  // for the following object;\n *  { name: 'John', billing: { account: { id: 1, active: true } } };\n *\n *  'billing.account.*'  // represents value `{ id: 1, active: true }`\n *  'billing.account.id' // represents value `1`\n *  '!billing.account.*' // represents value `{ name: 'John' }`\n *  'name' // represents `'John'`\n *  '*' // represents the whole object\n *\n *  @example\n *  var glob = new Notation.Glob('billing.account.*');\n *  glob.test('billing.account.id'); // true\n */\nclass NotationGlob {\n\n    /**\n     *  Constructs a `Notation.Glob` object with the given glob string.\n     *  @constructs Notation.Glob\n     *\n     *  @param {String} glob - The glob string.\n     */\n    constructor(glob) {\n        if (!NotationGlob.isValid(glob)) {\n            throw new NotationError('Invalid notation glob: \"' + glob + '\"');\n        }\n\n        let ng = NotationGlob.inspect(glob);\n        this._ = {\n            glob,\n            absGlob: ng.absGlob,\n            isNegated: ng.isNegated,\n            regexp: NotationGlob.toRegExp(ng.absGlob),\n            levels: ng.absGlob.split('.')\n        };\n    }\n\n    // --------------------------------\n    // NotationGlob Instance Properties\n    // --------------------------------\n\n    /**\n     *  Gets the original glob notation string.\n     *  @name Notation.Glob#glob\n     *  @type {String}\n     */\n    get glob() {\n        return this._.glob;\n    }\n\n    /**\n     *  Gets the absolute glob notation (without the preceeding bang `!`).\n     *  @name Notation.Glob#absGlob\n     *  @type {String}\n     */\n    get absGlob() {\n        return this._.absGlob;\n    }\n\n    /**\n     *  Specifies whether this glob is negated with a `!` prefix.\n     *  @name Notation.Glob#isNegated\n     *  @type {Boolean}\n     */\n    get isNegated() {\n        return this._.isNegated;\n    }\n\n    /**\n     *  Represents this glob in regular expressions.\n     *  Note that the negation (`!`) is ignored, if any.\n     *  @name Notation.Glob#regexp\n     *  @type {RegExp}\n     */\n    get regexp() {\n        return this._.regexp;\n    }\n\n    /**\n     *  List of notes/levels of this glob notation.\n     *  @name Notation.Glob#notes\n     *  @alias Notation.Glob#levels\n     *  @type {Array}\n     */\n    get notes() {\n        return this._.levels;\n    }\n    /**\n     *  Alias of `Notation.Glob#notes`.\n     *  @private\n     */\n    get levels() {\n        return this._.levels;\n    }\n\n    // --------------------------------\n    // NotationGlob Instance Methods\n    // --------------------------------\n\n    /**\n     *  Checks whether the given notation value matches the source notation glob.\n     *  @name Notation.Glob#test\n     *  @function\n     *\n     *  @param {String} notation - The notation string to be tested.\n     *\n     *  @returns {Boolean}\n     *\n     *  @example\n     *  const glob = new Notation.Glob('!prop.*.name');\n     *  glob.test(\"prop.account.name\"); // true\n     */\n    test(notation) {\n        // we allow '*' to match everything. We check for this here\n        // instead of the regexp bec. we care for dots (.) within the glob.\n        return this.absGlob === '*'\n            || (this.absGlob !== '' && notation !== '' && this.regexp.test(notation));\n    }\n\n    // --------------------------------\n    // NotationGlob Static Members\n    // --------------------------------\n\n    /**\n     *  Basically constructs a new `NotationGlob` instance\n     *  with the given glob string.\n     *  @name Notation.Glob.create\n     *  @function\n     *\n     *  @param {String} glob - The source notation glob.\n     *\n     *  @returns {NotationGlob}\n     *\n     *  @example\n     *  const glob = Notation.Glob.create(strGlob);\n     *  // equivalent to:\n     *  const glob = new Notation.Glob(strGlob);\n     */\n    static create(glob) {\n        return new NotationGlob(glob);\n    }\n\n    /**\n     *  Gets a regular expressions instance from the given glob notation.\n     *  Note that the bang `!` prefix will be ignored if the given glob is negated.\n     *  @name Notation.Glob.toRegExp\n     *  @function\n     *\n     *  @param {String} glob - Glob notation to be converted.\n     *\n     *  @returns {RegExp}\n     */\n    static toRegExp(glob) {\n        if (glob.indexOf('!') === 0) glob = glob.slice(1);\n        // Modified from http://stackoverflow.com/a/13818704/112731\n        glob = utils.pregQuote(glob)\n            .replace(/\\\\\\*/g, '[^\\\\s\\\\.]*')\n            .replace(/\\\\\\?/g, '.');\n        return new RegExp('^' + glob + '(\\\\..+|$)');\n        // it should either end ($) or continue with a dot. So for example,\n        // `company.*` will produce `/^company\\.[^\\s\\.]*/` which will match both\n        // `company.name` and `company.address.street` but will not match\n        // `some.company.name`. Also `!password` will not match `!password_reset`.\n    }\n\n    /**\n     *  @private\n     */\n    static inspect(glob) {\n        let bang = glob.slice(0, 1) === '!';\n        glob = bang ? glob.slice(1) : glob;\n        return {\n            absGlob: glob,\n            isNegated: bang\n        };\n    }\n\n    // Created test at: https://regex101.com/r/tJ7yI9/4\n    // regex from https://github.com/BenoitRanque/notation\n    /**\n     *  Validates the given notation glob.\n     *  @name Notation.Glob.isValid\n     *  @function\n     *\n     *  @param {String} glob - Notation glob to be validated.\n     *  @returns {Boolean}\n     */\n    static isValid(glob) {\n        return (typeof glob === 'string')\n            && (/^(!?([^\\s.!*\\[\\]]+|\\*)((\\.([^\\s.!*\\[\\]]+|\\*))|(\\[([0-9]+|\\*)\\]))*)$/).test(glob);\n    }\n\n    /**\n     *  Compares two given notation globs and returns an integer value as a\n     *  result. This is generally used to sort glob arrays. Loose globs (with\n     *  stars especially closer to beginning of the glob string) and globs\n     *  representing the parent/root of the compared property glob come first.\n     *  Verbose/detailed/exact globs come last. (`* < *abc < abc`).\n     *\n     *  For instance; `store.address` comes before `store.address.street`. So\n     *  this works both for `*, store.address.street, !store.address` and `*,\n     *  store.address, !store.address.street`. For cases such as `prop.id` vs\n     *  `!prop.id` which represent the same property; the negated glob wins\n     *  (comes last).\n     *  @name Notation.Glob.compare\n     *  @function\n     *\n     *  @param {String} a - First notation glob to be compared.\n     *  @param {String} b - Second notation glob to be compared.\n     *\n     *  @returns {Number} - Returns `-1` if `a` comes first, `1` if `b` comes\n     *  first and `0` if equivalent priority.\n     *\n     *  @example\n     *  let result = Notation.Glob.compare('prop.*.name', 'prop.*');\n     *  console.log(result); // 1\n     */\n    static compare(a, b) {\n        // trivial case, both are exactly the same!\n        if (a === b) return 0;\n        let levelsA = a.split('.'),\n            levelsB = b.split('.');\n        // Check depth (number of levels)\n        if (levelsA.length === levelsB.length) {\n            // count wildcards (assuming more wildcards comes first)\n            let wild = /(?:^|\\.)\\*(?:$|\\.)/g,\n                mA = a.match(wild),\n                mB = b.match(wild),\n                wildA = mA ? mA.length : 0,\n                wildB = mB ? mB.length : 0;\n            if (wildA === wildB) {\n                // check for negation\n                let negA = a.indexOf('!') === 0,\n                    negB = b.indexOf('!') === 0;\n                if (negA === negB) {\n                    // both are negated or neither are, just return alphabetical\n                    return a < b ? -1 : 1;\n                }\n                // compare without the negatation\n                let nonNegA = negA ? a.slice(1) : a,\n                    nonNegB = negB ? b.slice(1) : b;\n                if (nonNegA === nonNegB) {\n                    return negA ? 1 : -1;\n                }\n                return nonNegA < nonNegB ? -1 : 1;\n            }\n            return wildA > wildB ? -1 : 1;\n        }\n\n        return levelsA.length < levelsB.length ? -1 : 1;\n    }\n\n    /**\n     *  Sorts the notation globs in the given array by their priorities. Loose\n     *  globs (with stars especially closer to beginning of the glob string);\n     *  globs representing the parent/root of the compared property glob come\n     *  first. Verbose/detailed/exact globs come last. (`* < *abc < abc`).\n     *\n     *  For instance; `store.address` comes before `store.address.street`. For\n     *  cases such as `prop.id` vs `!prop.id` which represent the same property;\n     *  the negated glob wins (comes last).\n     *  @name Notation.Glob.sort\n     *  @function\n     *\n     *  @param {Array} globsArray - The notation globs array to be sorted. The\n     *  passed array reference is modified.\n     *\n     *  @returns {Array}\n     *\n     *  @example\n     *  const globs = ['!prop.*.name', 'prop.*', 'prop.id'];\n     *  const sorted = Notation.Glob.sort(globs);\n     *  console.log(sorted);\n     *  // ['prop.*', 'prop.id', '!prop.*.name'];\n     */\n    static sort(globsArray) {\n        return globsArray.sort(NotationGlob.compare);\n        // return _mergeSortArray(globsArray, NotationGlob.compare);\n    }\n\n    /**\n     *  Normalizes the given notation globs array by removing duplicate or\n     *  redundant items and returns a priority-sorted globs array.\n     *\n     *  <ul>\n     *  <li>If any exact duplicates found, all except first is removed.</li>\n     *  <li>If both normal and negated versions of a glob are found, negated wins.\n     *  <br />example: `['id', '!id']` normalizes to `['!id']`.</li>\n     *  <li>If a glob is covered by another, it's removed.\n     *  <br />example: `['car.*', 'car.model']` normalizes to `['car.*']`.</li>\n     *  <li>If a glob is covered by another negated glob, it's kept.\n     *  <br />example: `['*', '!car.*', 'car.model']` normalizes as is.</li>\n     *  <li>If a negated glob is covered by another glob, it's also kept.\n     *  <br />example: `['car.*', '!car.model']` normalizes as is.</li>\n     *  </ul>\n     *  @name Notation.Glob.normalize\n     *  @function\n     *\n     *  @param {Array} globsArray - Notation globs array to be normalized.\n     *\n     *  @returns {Array}\n     *\n     *  @example\n     *  const globs = ['*', '!id', 'name', 'car.model', '!car.*', 'id', 'name', 'age'];\n     *  const normalized = Notation.Glob.normalize(globs);\n     *  console.log(normalized);\n     *  // ['*', '!car.*', '!id', 'car.model']\n     */\n    static normalize(globsArray) {\n        globsArray = utils.ensureArray(globsArray).map(item => item.trim());\n        globsArray = NotationGlob.sort(globsArray);\n\n        utils.eachRight(globsArray, (globA, indexA) => {\n\n            // example #1:\n            // ['*', '!id', 'name', 'car.model', '!car.*', 'id', 'name']\n            // => ['*', '!id', '!car.*', 'car.model']\n\n            // example #2:\n            // ['!id', 'name', 'car.model', '!car.*', 'id', '!email']\n            // => ['!car.*', 'car.model', 'name']\n\n            let insA = NotationGlob.inspect(globA);\n            // console.log(' • ', globA, '=>', globsArray);\n\n            let duplicate = false;\n            let hasExactNegative = false;\n            let negCoversNeg = false;\n            let noPosCoversNeg = true;\n            let posCoversPos = false;\n            let noNegCoversPos = true;\n\n            // inspect/compare the current glob with the rest of the array\n            utils.eachRight(globsArray, (globB, indexB) => {\n                // don't inspect glob with itself\n                if (indexB === indexA) return; // no break, move to next\n\n                let insB = NotationGlob.inspect(globB);\n                let reB = NotationGlob.toRegExp(insB.absGlob);\n\n                // console.log(globA, 'vs', globB);\n\n                // (A) remove if duplicate\n                if (globA === globB) {\n                    duplicate = true;\n                    return false; // break\n                }\n\n                // (B) remove if positive has an exact negative\n                // e.g. ['prop', '!prop'] => ['!prop']\n                // negated wins when normalized\n                if (insB.isNegated && globA === insB.absGlob) {\n                    hasExactNegative = true;\n                    return false; // break\n                }\n\n                // (C) remove negated if:\n                //    1) any negative covers it\n                //       ['!a.b', '!a.*']  => '!a.b' is removed\n                //    2) no positive covers it\n                //       ['!a.b', 'a.c']   => '!a.b' is removed\n\n                // (D) remove positive if:\n                //    1) any positive covers it AND no negative covers it\n                //       ['*', 'a.b']            => 'a.b' is removed\n                //       ['*', 'a.b', '!a.*']    => 'a.b' is kept\n\n                if (insA.isNegated) {\n                    if (insB.isNegated && reB.test(insA.absGlob)) {\n                        negCoversNeg = true;\n                        return false; // break\n                    } else if (noPosCoversNeg && reB.test(insA.absGlob)) {\n                        noPosCoversNeg = false;\n                    }\n                } else { // if (!insA.isNegated)\n                    if (!insB.isNegated && reB.test(insA.absGlob)) {\n                        posCoversPos = true;\n                    } else if (noNegCoversPos && reB.test(insA.absGlob)) {\n                        noNegCoversPos = false;\n                    }\n                }\n\n            });\n\n            let redundant = insA.isNegated\n                ? (negCoversNeg || noPosCoversNeg)\n                : (posCoversPos && noNegCoversPos);\n\n            if (duplicate || hasExactNegative || redundant) {\n                // remove the current (at the end)\n                globsArray.splice(indexA, 1);\n            }\n\n        });\n\n        // since negated wins in the same array, ['*', '!*'] is already reduced\n        // to ['!*'] so we can safely remove !* if found, since it's redundant.\n        // e.g. ['!*', 'name'] => ['name']\n        let i = globsArray.indexOf('!*');\n        if (i >= 0) globsArray.splice(i, 1);\n\n        return globsArray;\n    }\n\n    /**\n     *  Gets the union from the given couple of glob arrays and returns\n     *  a new array of globs.\n     *  <ul>\n     *  <li>If the exact same element is found in both\n     *  arrays, one of them is removed to prevent duplicates.\n     *  <br />example: `['!id', 'name'] ∪ ['!id']` unites to `['!id', 'name']`</li>\n     *  <li>If any non-negated item is covered by a glob in the same\n     *  or other array, the redundant item is removed.\n     *  <br />example: `['*', 'name'] ∪ ['email']` unites to `['*']`</li>\n     *  <li>If one of the arrays contains a negated equivalent of an\n     *  item in the other array, the negated item is removed.\n     *  <br />example: `['!id'] ∪ ['id']` unites to `['id']`</li>\n     *  <li>If any item covers/matches a negated item in the other array,\n     *  the negated item is removed.\n     *  <br />example #1: `['!user.id'] ∪ ['user.*']` unites to `['user.*']`\n     *  <br />example #2: `['*'] ∪ ['!password']` unites to `['*']`\n     *  </li>\n     *  <li>So on... For a better understanding read the inline code\n     *  documentation.</li>\n     *  </ul>\n     *  @name Notation.Glob.union\n     *  @function\n     *\n     *  @param {Array} globsA - First array of glob strings.\n     *  @param {Array} globsB - Second array of glob strings.\n     *\n     *  @returns {Array}\n     *\n     *  @example\n     *  const a = ['foo.bar', 'bar.baz', '!*.qux'];\n     *  const b = ['!foo.bar', 'bar.qux', 'bar.baz'];\n     *  const union = Notation.Glob.union(a, b);\n     *  console.log(union);\n     *  // ['!*.qux', 'foo.bar', 'bar.baz', 'bar.qux']\n     */\n    static union(globsA, globsB) {\n        // NOTE: The logic here is quite complex. For making this easier to\n        // understand; below code is written a bit verbose. Do not modify this\n        // only to make it shorter. This will already get minified.\n\n        // -----------------------\n\n        // if any of the arrays has a single glob item of only a wildcard (e.g.\n        // `['*']`); this covers all, so...\n        if (utils.hasSingleItemOf(globsA, '*') || utils.hasSingleItemOf(globsB, '*')) {\n            return ['*'];\n        }\n\n        // clone arrays so we don't mutate the originals.\n        const arrA = globsA.concat();\n        const arrB = globsB.concat();\n        // no need to normalize. we'll do it at the end.\n\n        let reA, reB, insA, insB;\n\n        // storage for tracking (winner) negated globs that are compared with\n        // another negated in the other array. For example:\n        // ['*', '!user.*'] ∪ ['*', '!user.id']\n        // '!user.id' should be kept in the union when compared with '!user.*'.\n        // but later, '!user.id' will be unioned with '*' in the other array\n        // which will cover and remove '!user.id'. so we'll keep a storage for\n        // to prevent this.\n        let keepNegated = [];\n\n        // iterate through array A\n        utils.eachRight(arrA, (a, aIndex) => {\n            insA = NotationGlob.inspect(a);\n            reA = NotationGlob.toRegExp(insA.absGlob);\n\n            // iterate through array B for each item in A\n            utils.eachRight(arrB, (b, bIndex) => {\n                insB = NotationGlob.inspect(b);\n                reB = NotationGlob.toRegExp(insB.absGlob);\n\n                // console.log(a, 'vs', b);\n\n                if (insA.isNegated && !insB.isNegated) {\n                    // if we have the non-negated version of the same glob in B,\n                    // we'll remove item in A. In union, non-negated wins\n                    // (unlike normalize — in normalize, negated wins within the\n                    // same array).\n                    if (insA.absGlob === insB.absGlob) {\n                        arrA.splice(aIndex, 1);\n                        // console.log(`${a} removed: ${a} reverses ${b}`);\n                        // console.log(arrA, '∪', arrB);\n                        return false; // break from B\n                    }\n\n                    // remove the negated from A only if the same value is not in B.\n                    // e.g. 1)  ['!x.y'] ∪ ['x.*'] => ['x.*']\n                    // e.g. 2)  ['!x.y'] ∪ ['x.*', '!x.y'] => ['x.*', '!x.y']\n                    if (reB.test(insA.absGlob) && arrB.indexOf(a) === -1 && keepNegated.indexOf(a) === -1) {\n                        arrA.splice(aIndex, 1);\n                        // console.log(`${a} removed: ${b} covers ${a}`);\n                        // console.log(arrA, '∪', arrB);\n                        return false; // break from B\n                    }\n                }\n\n                if (!insA.isNegated && insB.isNegated) {\n                    // if we have the non-negated version of the same glob in A,\n                    // we'll remove item in B.\n                    if (insA.absGlob === insB.absGlob) {\n                        arrB.splice(bIndex, 1);\n                        // console.log(`${b} removed: ${b} reverses ${a}`);\n                        // console.log(arrA, '∪', arrB);\n                        return; // move to next in B\n                    }\n\n                    // remove the negated from B only if the same value is not in A.\n                    // e.g. 1)  ['!x.y'] ∪ ['x.*'] => ['x.*']\n                    // e.g. 2)  ['!x.y'] ∪ ['x.*', '!x.y'] => ['x.*', '!x.y']\n                    if (reA.test(insB.absGlob) && arrA.indexOf(b) === -1 && keepNegated.indexOf(b) === -1) {\n                        arrB.splice(bIndex, 1);\n                        // console.log(`${b} removed: ${a} covers ${b}`);\n                        // console.log(arrA, '∪', arrB);\n                        return; // move to next in B\n                    }\n                }\n\n                if (insA.isNegated && insB.isNegated) {\n                    // if both A and B are negated and NOT equal, we'll check\n                    // for coverage over one or the other.\n                    if (a !== b) {\n                        // if B covers A, we'll remove from B.\n                        // e.g. '!user.*' covers '!user.id'\n                        if (reB.test(insA.absGlob)) {\n                            arrB.splice(bIndex, 1);\n                            keepNegated.push(a);\n                            // console.log(`${b} removed: ${a} neg-covers ${b}`);\n                            // console.log(arrA, '∪', arrB);\n                            return; // move to next in B\n                        }\n                        // if A covers B, we'll remove from A.\n                        if (reA.test(insB.absGlob)) {\n                            arrA.splice(aIndex, 1);\n                            keepNegated.push(b);\n                            // console.log(`${a} removed: ${b} neg-covers ${a}`);\n                            // console.log(arrA, '∪', arrB);\n                            return false; // break from B\n                        }\n                    }\n                    // else, if they are equal, we'll not remove any bec. it\n                    // means both arrays disalow that glob.\n                }\n\n                if (!insA.isNegated && !insB.isNegated) {\n                    // if both A and B are NOT negated and equal, we'll remove\n                    // from A.\n                    if (a === b) {\n                        arrA.splice(aIndex, 1);\n                        // console.log(`${a} removed: ${a} === ${b}`);\n                        // console.log(arrA, '∪', arrB);\n                        return false;\n                    }\n\n                    // else -> (a !== b)\n\n                    // Leave the rest to the normalizing process\n                    // (Notation.Glob.normalize) bec. when both A and B are\n                    // non-negated, the one which is covered by the other will\n                    // be removed incorrectly.\n\n                    // For example:\n                    // ['!x.y'] ∪ ['x.*'] => ['x.*']\n                    // ['*', '!x.*'] ∪ ['*', '!x.*', 'x.o']\n                    // '*' in A will cover and remove 'x.o' in B incorrectly bec.\n                    // 'x.o' is a remainder from '!x.*' which is both in A and B.\n\n                    // So when this is left as is; the final union before\n                    // normalizing is: ['*', '!x.*', '*', 'x.o']\n                    // normalized to:  ['*', '!x.*', 'x.o']\n\n                    // if (reB.test(insA.absGlob)) {\n                    //     arrA.splice(aIndex, 1);\n                    //     console.log(`${a} removed: ${b} covers ${a}`);\n                    //     console.log(arrA, '∪', arrB);\n                    //     return false;\n                    // }\n                    // if (reA.test(insB.absGlob)) {\n                    //     arrB.splice(bIndex, 1);\n                    //     console.log(`${b} removed: ${a} covers ${b}`);\n                    //     console.log(arrA, '∪', arrB);\n                    //     return;\n                    // }\n                }\n\n            });\n        });\n\n        // concat both arrays, normalize and sort so we get a nice union array.\n        const result = arrA.concat(arrB);\n        return NotationGlob.normalize(result);\n    }\n\n}\n\nexport default NotationGlob;\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/notation.glob.js"],"sourceRoot":""}